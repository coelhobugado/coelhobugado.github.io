<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Mapas Mentais Tradicionais com IA</title>
    <!-- Biblioteca para exportar SVG como PNG -->
    <script src="https://cdn.jsdelivr.net/npm/save-svg-as-png@1.4.17/lib/saveSvgAsPng.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Cores base */
            --primary-color: #5b86e5;
            --secondary-color: #36d1dc;
            --light-bg: #fdfdff;
            --text-color: #333;
            --node-text-color: white;
            --border-radius: 10px;
            --shadow: 0 6px 20px rgba(0,0,0,0.1);

            /* Cores para o tema claro (padr√£o) */
            --body-bg: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            --container-header-text-color: white;
            --input-section-bg: white;
            --input-label-color: #555;
            --textarea-border-color: #e0e0e0;
            --textarea-focus-border-color: var(--primary-color);
            --textarea-focus-shadow-color: rgba(91, 134, 229, 0.25);
            --btn-secondary-bg: #f5f5f5;
            --btn-secondary-text-color: var(--text-color);
            --btn-secondary-border-color: #ddd;
            --btn-secondary-hover-bg: #e8e8e8;
            --btn-secondary-hover-border-color: #ccc;
            --loading-text-color: white;
            --mindmap-container-bg: var(--light-bg);
            --mindmap-svg-bg: #ffffff;
            --control-btn-bg: rgba(0,0,0,0.7);
            --control-btn-hover-bg: rgba(0,0,0,0.85);
            --debug-info-bg: rgba(40,40,40,0.8);
            --debug-info-text-color: #f0f0f0;
            --error-message-bg: #fff0f0;
            --error-message-text-color: #d32f2f;
            --error-message-border-color: #ffcdd2;
            --link-path-stroke-default: #777; /* Cor base para links no tema claro */
            --arrowhead-fill-color: #777; /* Cor padr√£o da seta */
        }

        .dark-theme {
            --primary-color: #7A86B6; /* Roxo acinzentado */
            --secondary-color: #4A5568; /* Cinza azulado escuro */
            --light-bg: #2d3748;    /* Cinza muito escuro para fundos principais */
            --text-color: #e2e8f0;   /* Cinza claro para texto geral */
            --node-text-color: #f7fafc; /* Branco quase puro para texto do n√≥ */

            --body-bg: linear-gradient(135deg, #2c3e50 0%, #1f2937 100%);
            --container-header-text-color: #e2e8f0;
            --input-section-bg: #2d3748; /* Cinza escuro para se√ß√µes de input */
            --input-label-color: #a0aec0; /* Cinza m√©dio para labels */
            --textarea-border-color: #4a5568; /* Cinza mais escuro para bordas */
            --textarea-focus-border-color: var(--primary-color);
            --textarea-focus-shadow-color: rgba(122, 134, 182, 0.3);
            --btn-secondary-bg: #4a5568;
            --btn-secondary-text-color: #e2e8f0;
            --btn-secondary-border-color: #718096;
            --btn-secondary-hover-bg: #2d3748;
            --btn-secondary-hover-border-color: #a0aec0;
            --loading-text-color: #e2e8f0;
            --mindmap-container-bg: #1a202c; /* Fundo bem escuro para o container do mapa */
            --mindmap-svg-bg: #283141; /* Fundo escuro para o SVG */
            --control-btn-bg: rgba(255,255,255,0.15);
            --control-btn-hover-bg: rgba(255,255,255,0.25);
            --debug-info-bg: rgba(20,20,20,0.85);
            --debug-info-text-color: #cbd5e0;
            --error-message-bg: #4a2426; /* Vermelho escuro para fundo de erro */
            --error-message-text-color: #feb2b2; /* Vermelho claro para texto de erro */
            --error-message-border-color: #c53030; /* Vermelho para borda de erro */
            --link-path-stroke-default: #9eadbf; /* Cor base para links no tema escuro */
            --arrowhead-fill-color: #9eadbf; /* Cor da seta para tema escuro */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--body-bg);
            min-height: 100vh;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow-x: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px; 
            width: 95%;
            margin: 0 auto;
            padding: 15px;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            color: var(--container-header-text-color);
            position: relative; /* Added for positioning context for the emoji toggle */
        }

        #emojiThemeToggle {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8rem; /* Larger emoji */
            cursor: pointer;
            padding: 5px;
            user-select: none; /* Prevent text selection */
            transition: transform 0.2s ease;
        }
        #emojiThemeToggle:hover {
            transform: scale(1.15);
        }

        .header h1 {
            font-size: 2.3rem;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.15);
        }

        .header p {
            font-size: 1rem;
            opacity: 0.95;
        }

        .input-section {
            background: var(--input-section-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--shadow);
            transition: background 0.3s ease;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group:last-of-type { /* Ensure last input group in a section also has margin if needed */
            margin-bottom: 0; /* Or adjust as per visual design with buttons */
        }


        label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--input-label-color);
            transition: color 0.3s ease;
        }

        textarea {
            width: 100%;
            padding: 14px;
            border: 1px solid var(--textarea-border-color);
            border-radius: 8px;
            font-size: 0.95rem;
            font-family: 'Poppins', sans-serif;
            resize: vertical;
            min-height: 120px; 
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
            background-color: var(--input-section-bg); 
            color: var(--text-color);
        }
        
        select { /* New styles for select element */
            width: 100%;
            padding: 10px 12px; /* Adjusted padding */
            border: 1px solid var(--textarea-border-color);
            border-radius: 8px;
            font-size: 0.9rem; /* Adjusted font size */
            font-family: 'Poppins', sans-serif;
            margin-top: 5px; /* Space between label and select */
            background-color: var(--input-section-bg);
            color: var(--text-color);
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--textarea-focus-border-color);
            box-shadow: 0 0 0 2.5px var(--textarea-focus-shadow-color);
        }


        textarea:focus {
            outline: none;
            border-color: var(--textarea-focus-border-color);
            box-shadow: 0 0 0 2.5px var(--textarea-focus-shadow-color);
        }

        .button-group {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 11px 25px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.25s ease;
            letter-spacing: 0.3px;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white; 
            box-shadow: 0 3px 12px rgba(0,0,0,0.1);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 18px rgba(91, 134, 229, 0.35);
        }

        .btn-secondary {
            background: var(--btn-secondary-bg);
            color: var(--btn-secondary-text-color);
            border: 1px solid var(--btn-secondary-border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--btn-secondary-hover-bg);
            border-color: var(--btn-secondary-hover-border-color);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 25px;
            color: var(--loading-text-color);
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.25);
            border-radius: 50%;
            border-top: 4px solid var(--container-header-text-color); 
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mindmap-container {
            background: var(--mindmap-container-bg);
            border-radius: var(--border-radius);
            padding: 10px;
            box-shadow: var(--shadow);
            min-height: 600px; 
            height: 70vh; 
            overflow: hidden;
            position: relative;
            transition: background 0.3s ease;
        }

        .mindmap-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            border: none;
            background: var(--control-btn-bg);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; 
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25); 
        }

        .control-btn:hover {
            background: var(--control-btn-hover-bg);
            transform: scale(1.1);
        }

        #mindMapSvg {
            width: 100%;
            height: 100%;
            cursor: grab;
            background-color: var(--mindmap-svg-bg);
            border-radius: calc(var(--border-radius) - 4px);
            transition: background-color 0.3s ease;
        }

        #mindMapSvg:active {
            cursor: grabbing;
        }

        .node-group .node-rect {
            stroke-width: 2px; 
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.15)); 
            transition: filter 0.2s ease, transform 0.2s ease, fill 0.3s ease, stroke 0.3s ease;
        }

        .node-group:hover .node-rect {
             filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.25));
             transform: translateY(-1px) scale(1.02); 
        }

        .node-text {
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: var(--node-text-color);
            transition: fill 0.3s ease;
        }

        .link-path {
            stroke-opacity: 0.7;
            stroke-width: 2.5px; 
            fill: none;
            transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease, stroke 0.3s ease;
        }

        .link-path:hover { 
            stroke-opacity: 1;
            stroke-width: 3.5px;
        }

        .error-message { 
            background: var(--error-message-bg);
            color: var(--error-message-text-color);
            border: 1px solid var(--error-message-border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 0.9rem;
            transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        .hidden {
            display: none !important; 
        }

        .debug-info {
            position: absolute;
            top: 12px;
            left: 12px;
            background: var(--debug-info-bg); 
            color: var(--debug-info-text-color);
            padding: 10px;
            border-radius: 6px;
            font-size: 11px; 
            font-family: monospace;
            z-index: 1001;
            opacity: 0.9;
            display: none; 
            transition: background 0.3s ease, color 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Gerador de Mapas Mentais</h1>
            <p>Visualize suas ideias com mapas mentais criados por IA</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="textInput">Insira o texto base para o seu mapa mental:</label>
                <textarea id="textInput" placeholder="Ex: Planejamento de um projeto, resumo de um livro, ideias para um novo neg√≥cio..."></textarea>
            </div>
            <div class="input-group" style="margin-bottom: 25px;"> {/* Added margin-bottom here */}
                <label for="layoutSelect">Escolha o Layout do Mapa:</label>
                <select id="layoutSelect">
                    <option value="organic">Org√¢nico (Padr√£o)</option>
                    <option value="hierarchical-top-down">Hier√°rquico (Cima para Baixo)</option>
                    <option value="hierarchical-left-right">Hier√°rquico (Esquerda para Direita)</option>
                    <option value="radial" disabled>Radial (Em breve)</option>
                    {/* <option value="cluster" disabled>Cluster (Em breve)</option> */}
                </select>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="generateMapBtn" onclick="generateMindMap()">üí° Gerar Mapa Mental</button>
                <button class="btn-secondary" onclick="clearAll()">üóëÔ∏è Limpar Tudo</button>
                <button class="btn-secondary" id="exportPngBtn" disabled>üñºÔ∏è Exportar PNG</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Criando seu mapa mental...</p>
        </div>

        <div id="errorContainer"></div> 
        <div class="mindmap-container hidden" id="mindMapContainer">
            <div class="debug-info" id="debugInfo"></div>
            <div class="mindmap-controls">
                <button class="control-btn" onclick="zoomInHandler()" title="Aproximar Zoom">+</button>
                <button class="control-btn" onclick="zoomOutHandler()" title="Afastar Zoom">-</button>
                <button class="control-btn" onclick="resetViewHandler()" title="Recentralizar">üéØ</button>
            </div>
            <svg id="mindMapSvg">
                <defs>
                    <!-- Marker para a seta dos links, sua cor agora usa uma vari√°vel CSS -->
                    <marker id="arrowhead" markerWidth="8" markerHeight="6" 
                            refX="7" refY="3" orient="auto-start-reverse">
                        <polygon points="0 0, 8 3, 0 6" fill="var(--arrowhead-fill-color)" />
                    </marker>
                </defs>
                <g id="mindMapRootGroup"></g>
            </svg>
        </div>
    </div>

    <script>
        let userApiKey = null; // Chave API ser√° fornecida pelo utilizador
        const GEMINI_MODEL_NAME = "gemini-1.5-flash-latest"; // Usando o modelo mais recente e otimizado

        const SVG_NAMESPACE = "http://www.w3.org/2000/svg";

        // Cores dos n√≥s ajustadas para melhor contraste em ambos os temas
        const NODE_COLORS_LIGHT = ['#5b86e5', '#45b6fe', '#36d1dc', '#f09819', '#cb356b', '#9b59b6', '#2ecc71', '#e74c3c'];
        const NODE_COLORS_DARK = ['#7A86B6', '#5C9EBF', '#4A7F83', '#D4882C', '#B04E5D', '#8A6AA1', '#3E8E41', '#C0392B'];

        const NODE_PADDING = { x: 20, y: 12 };
        const BASE_NODE_HEIGHT = 45;
        const BASE_FONT_SIZE = 12;
        const MAX_TEXT_LENGTH = 30; 
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 3;

        // Settings for 'default' (organic) layout
        const LEVEL_DISTANCE_FACTOR = 200; 
        const MIN_ANGLE_BETWEEN_BRANCHES = Math.PI / 7; 
        
        // Settings for 'hierarchical-top-down' layout
        const HIERARCHICAL_LEVEL_GAP = 40; // Vertical distance between centers of node levels
        const HIERARCHICAL_SIBLING_GAP = 25; // Horizontal distance between edges of sibling nodes/subtrees

        let svgElement, rootGroup, debugInfoElement, generateMapButton, emojiThemeToggleElement, exportPngButtonElement;
        let currentScale = 1;
        let currentTranslateX = 0;
        let currentTranslateY = 0;
        let isDragging = false;
        let lastPointerX = 0;
        let lastPointerY = 0;
        // nodePositions agora armazenar√° { x, y, width, height, originalData, level, branchIndex, parentKey, id }
        let nodePositions = new Map(); 
        let currentTheme = 'light'; // Estado inicial do tema

        const textInputElement = document.getElementById('textInput');
        const loadingElement = document.getElementById('loading');
        const mindMapContainerElement = document.getElementById('mindMapContainer');
        const errorContainerElement = document.getElementById('errorContainer');

        function getCurrentNodeColors() {
            return currentTheme === 'light' ? NODE_COLORS_LIGHT : NODE_COLORS_DARK;
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.classList.toggle('dark-theme', currentTheme === 'dark');
            if (emojiThemeToggleElement) {
                emojiThemeToggleElement.textContent = currentTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
            }
            // Se houver um mapa mental renderizado, re-renderiza para aplicar novas cores
            if (rootGroup && rootGroup.dataset.mindmapData) {
                 const currentData = JSON.parse(rootGroup.dataset.mindmapData);
                 if (currentData.central) {
                    nodePositions.clear(); 
                    // Get selected layout for re-rendering
                    const layoutSelectElement = document.getElementById('layoutSelect');
                    const selectedLayoutType = layoutSelectElement ? layoutSelectElement.value : 'organic';
                    renderMindMap(currentData, mindMapContainerElement.clientWidth, mindMapContainerElement.clientHeight, selectedLayoutType);
                 }
            }
        }

        function exportMindMapAsPng() {
            const svgToExport = document.getElementById('mindMapSvg');
            if (!svgToExport) {
                showError("Elemento SVG do mapa mental n√£o encontrado para exporta√ß√£o.");
                return;
            }

            let filename = "mapa_mental.png";
            try {
                // Tenta obter um nome mais descritivo do n√≥ central, se existir
                if (rootGroup && rootGroup.dataset.mindmapData) {
                    const mindMapData = JSON.parse(rootGroup.dataset.mindmapData);
                    if (mindMapData && mindMapData.central) {
                        const centralTitle = mindMapData.central.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                        if (centralTitle) {
                            filename = `${centralTitle.substring(0, 50)}_mapa_mental.png`;
                        }
                    }
                }
            } catch (e) {
                console.warn("N√£o foi poss√≠vel obter o t√≠tulo do mapa para o nome do arquivo, usando padr√£o.", e);
            }

            // Op√ß√µes para saveSvgAsPng
            const options = {
                backgroundColor: 'white', // Define um fundo branco para o PNG
                scale: 2, // Aumenta a resolu√ß√£o da imagem exportada
                encoderOptions: 0.92, // Qualidade do PNG
            };

            console.log(`Tentando exportar SVG como PNG: ${filename} com op√ß√µes:`, options);

            // A biblioteca saveSvgAsPng √© carregada via CDN e deve estar dispon√≠vel globalmente
            if (typeof saveSvgAsPng !== 'undefined' && typeof saveSvgAsPng.saveSvgAsPng === 'function') {
                try {
                    saveSvgAsPng.saveSvgAsPng(svgToExport, filename, options);
                    console.log("Tentativa de exporta√ß√£o PNG iniciada para:", filename);
                } catch (error) {
                    console.error("Erro durante a chamada de saveSvgAsPng:", error);
                    showError(`Erro ao tentar exportar PNG: ${error.message}`);
                }
            } else {
                console.error("Biblioteca saveSvgAsPng n√£o carregada ou fun√ß√£o saveSvgAsPng n√£o encontrada.");
                showError("Erro: A biblioteca de exporta√ß√£o PNG n√£o foi carregada corretamente. Verifique sua conex√£o ou tente recarregar a p√°gina.");
            }
        }

        function truncateText(text, maxLength = MAX_TEXT_LENGTH) {
            if (!text || typeof text !== 'string') return 'Sem T√≠tulo';
            text = text.trim();
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength - 3) + '...';
        }

        function checkCollision(x, y, width, height) {
            const R1 = { left: x - width / 2, right: x + width / 2, top: y - height / 2, bottom: y + height / 2 };
            for (let pos of nodePositions.values()) {
                const R2 = { left: pos.x - pos.width / 2, right: pos.x + pos.width / 2, top: pos.y - pos.height / 2, bottom: pos.y + pos.height / 2 };
                const buffer = 15; // Aumentado para mais espa√ßo entre n√≥s
                if (R1.left < R2.right + buffer && R1.right + buffer > R2.left && 
                    R1.top < R2.bottom + buffer && R1.bottom + buffer > R2.top) {
                    return true;
                }
            }
            return false;
        }

        function adjustPosition(initialX, initialY, width, height, nodeKeyPrefix, maxAttempts = 60, stepSize = 10) {
            let currentX = initialX;
            let currentY = initialY;
            let attempt = 0;
            const initialStepRadius = stepSize; 

            while (checkCollision(currentX, currentY, width, height) && attempt < maxAttempts) {
                attempt++;
                // Espiral de Fibonacci para distribuir melhor
                const angle = attempt * (Math.PI * (3 - Math.sqrt(5))); // √Çngulo dourado
                const radius = initialStepRadius + (attempt * stepSize * 0.15); // Raio crescente
                currentX = initialX + Math.cos(angle) * radius;
                currentY = initialY + Math.sin(angle) * radius;
            }
            if (attempt >= maxAttempts) {
                console.warn(`N√£o foi poss√≠vel encontrar posi√ß√£o livre de colis√£o para ${nodeKeyPrefix} ap√≥s ${maxAttempts} tentativas. Usando √∫ltima posi√ß√£o tentada.`);
            }
            return { x: currentX, y: currentY };
        }

        async function generateMindMap() {
            if (!userApiKey) {
                showError('Chave da API Gemini n√£o fornecida. Por favor, recarregue a p√°gina e insira a chave.');
                return;
            }

            const textInput = textInputElement.value.trim();
            if (!textInput) {
                showError('Por favor, insira um texto para gerar o mapa mental.');
                return;
            }
            if (textInput.length < 20) {
                showError('O texto precisa ter pelo menos 20 caracteres para gerar um mapa mental √∫til.');
                return;
            }

            showLoading(true);
            clearError(); 
            mindMapContainerElement.classList.add('hidden'); 
            // Limpa as posi√ß√µes de n√≥s anteriores ANTES de qualquer nova l√≥gica de c√°lculo.
            nodePositions.clear(); 

            try {
                const apiResponse = await callGeminiAPI(textInput);
                console.log("Resposta da API Gemini (Mapa Mental):", JSON.stringify(apiResponse, null, 2));

                if (rootGroup) {
                    rootGroup.dataset.mindmapData = JSON.stringify(apiResponse);
                }

                if (apiResponse && apiResponse.central && validateMindMapStructure(apiResponse)) {
                    mindMapContainerElement.classList.remove('hidden');
                    await new Promise(resolve => requestAnimationFrame(resolve));

                    const svgWidth = mindMapContainerElement.clientWidth;
                    const svgHeight = mindMapContainerElement.clientHeight;

                    // Get selected layout
                    const layoutSelectElement = document.getElementById('layoutSelect');
                    const selectedLayoutType = layoutSelectElement ? layoutSelectElement.value : 'organic';


                    if (svgWidth > 0 && svgHeight > 0) {
                        // nodePositions ser√° populado dentro de renderMindMap via calculateNodePositions
                        renderMindMap(apiResponse, svgWidth, svgHeight, selectedLayoutType);
                        if (exportPngButtonElement) exportPngButtonElement.disabled = false;
                    } else {
                        showError('Falha ao obter dimens√µes do container do mapa. Tente recarregar.');
                        mindMapContainerElement.classList.add('hidden');
                        if (exportPngButtonElement) exportPngButtonElement.disabled = true;
                    }
                } else {
                    showError('A IA n√£o retornou uma estrutura de mapa mental v√°lida ou completa. Tente novamente com um texto mais detalhado, ou ajuste o prompt na API.');
                    mindMapContainerElement.classList.add('hidden');
                    if (exportPngButtonElement) exportPngButtonElement.disabled = true;
                }
            } catch (error) {
                console.error("Erro em generateMindMap:", error);
                showError(`Erro ao gerar mapa mental: ${error.message}. Verifique o console para mais detalhes.`);
                mindMapContainerElement.classList.add('hidden');
                if (exportPngButtonElement) exportPngButtonElement.disabled = true;
            } finally {
                showLoading(false);
            }
        }

        function validateMindMapStructure(data) {
            if (!data.central || typeof data.central !== 'string' || data.central.trim() === '') {
                console.warn("Valida√ß√£o falhou: T√≥pico central ausente ou inv√°lido.");
                return false;
            }
            if (!data.branches) { // Se 'branches' n√£o existir, cria um array vazio para consist√™ncia
                 data.branches = [];
            }
            if (!Array.isArray(data.branches)) {
                console.warn("Valida√ß√£o falhou: 'branches' n√£o √© um array.");
                data.branches = []; // For√ßa ser um array vazio para evitar erros
            }

            // Garante que todos os t√≠tulos estejam truncados e existam
            function cleanNode(node) {
                if (node && typeof node.title === 'string') {
                    node.title = truncateText(node.title);
                } else {
                    node.title = 'N√≥ Inv√°lido'; // Define um t√≠tulo padr√£o para n√≥s inv√°lidos
                }
                if (node.children && Array.isArray(node.children)) {
                    node.children = node.children.filter(c => c && typeof c.title === 'string' && c.title.trim() !== '');
                    node.children.forEach(cleanNode);
                } else {
                    node.children = []; // Garante que children seja um array mesmo se vazio
                }
            }

            data.branches.forEach(cleanNode);

            return true;
        }

        async function callGeminiAPI(text) {
            if (!userApiKey) {
                 throw new Error("Chave da API Gemini n√£o est√° definida.");
            }
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent?key=${userApiKey}`;

            const prompt = `
Analise o seguinte texto e crie uma estrutura de MAPA MENTAL hier√°rquica e bem organizada em formato JSON.

INSTRU√á√ïES IMPORTANTES PARA A IA:
1.  **Central:** Use o conceito mais importante ou o t√≠tulo do texto como n√≥ "central". O t√≠tulo do n√≥ central deve ter no m√°ximo ${MAX_TEXT_LENGTH + 5} caracteres.
2.  **Ramos Principais (branches):** Crie entre 3 a 7 ramos principais significativos que se conectam diretamente ao n√≥ central. Cada "title" de ramo principal deve ter no m√°ximo ${MAX_TEXT_LENGTH} caracteres.
3.  **Sub-ramos (children):** Cada ramo principal pode ter, idealmente, entre 1 a 4 "children" (sub-ramos) que detalham o ramo principal. Se n√£o houver sub-ramos relevantes, omita "children" ou use um array vazio. Cada "title" de sub-ramo deve ter no m√°ximo ${MAX_TEXT_LENGTH} caracteres.
4.  **Profundidade:** Evite "children" de "children" (netos) com mais de 1 n√≠vel de profundidade. O n√≠vel m√°ximo de profundidade deve ser Central -> Ramo -> Filho -> Neto. O ideal √© Central -> Ramo -> Filho.
5.  **Qualidade dos T√≠tulos:** Use t√≠tulos claros, concisos e espec√≠ficos para cada n√≥.
6.  **Equil√≠brio:** Distribua as informa√ß√µes de forma equilibrada entre os ramos.
7.  **Formato:** O SEU RETORNO DEVE SER APENAS O OBJETO JSON V√ÅLIDO, SEM NENHUM TEXTO EXPLICATIVO, BLOCO DE C√ìDIGO (MARKDOWN), OU QUALQUER CARACTERE FORA DO OBJETO JSON.

ESTRUTURA JSON ESPERADA:
{
  "central": "T√≥pico Principal (m√°x ${MAX_TEXT_LENGTH + 5} chars)",
  "branches": [
    {
      "title": "Ramo 1 (m√°x ${MAX_TEXT_LENGTH} chars)",
      "children": [
        { "title": "Sub-ramo 1.1 (m√°x ${MAX_TEXT_LENGTH} chars)" },
        { "title": "Sub-ramo 1.2 (m√°x ${MAX_TEXT_LENGTH} chars)", "children": [{ "title": "Neto 1.2.1 (m√°x ${MAX_TEXT_LENGTH} chars)" }] }
      ]
    },
    { "title": "Ramo 2 (m√°x ${MAX_TEXT_LENGTH} chars)" }
  ]
}

Texto para an√°lise:
${text}
`;
            // Defini√ß√£o do schema JSON para garantir a sa√≠da esperada da IA
            const grandChildItemSchema = {
                type: "object",
                properties: { "title": { type: "string" } },
                required: ["title"],
                additionalProperties: false // Impede propriedades extras
            };

            const childItemSchema = {
                type: "object",
                properties: {
                    "title": { type: "string" },
                    "children": { type: "array", items: grandChildItemSchema }
                },
                required: ["title"],
                additionalProperties: false
            };

            const branchItemSchema = {
                type: "object",
                properties: {
                    "title": { type: "string" },
                    "children": { type: "array", items: childItemSchema }
                },
                required: ["title"],
                additionalProperties: false
            };

            const mindMapSchema = {
                type: "object",
                properties: {
                    "central": { type: "string" },
                    "branches": { type: "array", items: branchItemSchema }
                },
                required: ["central"],
                additionalProperties: false
            };

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json", // For√ßa a sa√≠da JSON
                    responseSchema: mindMapSchema, // For√ßa a sa√≠da a seguir este schema
                    temperature: 0.7, // Um pouco mais criativo
                    maxOutputTokens: 2048
                }
            };

            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`API Error: ${response.status}. Detalhes: ${errorBody.substring(0, 500)}`);
            }

            const data = await response.json();
            // Com responseMimeType e responseSchema, a IA deve retornar JSON direto.
            // A propriedade 'text' dentro de 'parts' conter√° o JSON gerado.
            if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                throw new Error('Resposta da API em formato inesperado ou vazia.');
            }

            const generatedText = data.candidates[0].content.parts[0].text;
            try {
                const parsed = JSON.parse(generatedText);
                
                // Trunca os textos novamente por seguran√ßa, caso a IA n√£o tenha respeitado o limite
                function  processNodeText(node) {
                    if (node.title) node.title = truncateText(node.title);
                    if (node.children) node.children.forEach(processNodeText);
                }
                if (parsed.central) parsed.central = truncateText(parsed.central, MAX_TEXT_LENGTH + 5);
                if (parsed.branches) parsed.branches.forEach(processNodeText);

                return parsed;
            } catch (e) {
                throw new Error(`A IA retornou um JSON inv√°lido ou mal formatado: ${generatedText.substring(0, 200)}. Erro: ${e.message}`);
            }
        }

        }


        // ==========================================================================================
        // NOVA L√ìGICA DE C√ÅLCULO DE POSI√á√ÉO
        // ==========================================================================================

        function calculateNodePositions(mindMapData, layoutType, svgWidth, svgHeight, targetNodePositionsMap, baseSettings) {
            targetNodePositionsMap.clear(); 

            // Ensure baseSettings has layout-specific default values if not already there
            baseSettings.LEVEL_DISTANCE_FACTOR = baseSettings.LEVEL_DISTANCE_FACTOR || LEVEL_DISTANCE_FACTOR;
            baseSettings.MIN_ANGLE_BETWEEN_BRANCHES = baseSettings.MIN_ANGLE_BETWEEN_BRANCHES || MIN_ANGLE_BETWEEN_BRANCHES;
            baseSettings.HIERARCHICAL_LEVEL_GAP = baseSettings.HIERARCHICAL_LEVEL_GAP || HIERARCHICAL_LEVEL_GAP;
            baseSettings.HIERARCHICAL_SIBLING_GAP = baseSettings.HIERARCHICAL_SIBLING_GAP || HIERARCHICAL_SIBLING_GAP;

            if (layoutType === 'hierarchical-top-down') {
                return calculateTopDownHierarchicalPositions(mindMapData, svgWidth, svgHeight, targetNodePositionsMap, baseSettings);
            } else if (layoutType === 'hierarchical-left-right') {
                return calculateLeftRightHierarchicalPositions(mindMapData, svgWidth, svgHeight, targetNodePositionsMap, baseSettings);
            }
             else { // Default to 'organic' layout
                const centerX = svgWidth / 2;
                const centerY = svgHeight / 2;
                const centralMetrics = calculateNodeMetrics(mindMapData.central, 0, true);
                const centralNodeId = 'central-org'; // Unique ID for organic central node
                targetNodePositionsMap.set(centralNodeId, {
                    id: centralNodeId, x: centerX, y: centerY, width: centralMetrics.width, height: centralMetrics.height,
                    originalData: { title: mindMapData.central, children: mindMapData.branches }, // Keep children accessible
                    level: 0, branchIndex: 0, parentKey: null,
                    displayText: centralMetrics.text, fontSize: centralMetrics.fontSize, fontWeight: centralMetrics.fontWeight
                });

                if (mindMapData.branches && mindMapData.branches.length > 0) {
                    const numBranches = mindMapData.branches.length;
                    let angleStep = (2 * Math.PI) / numBranches;
                    if (numBranches > 1 && angleStep < baseSettings.MIN_ANGLE_BETWEEN_BRANCHES) {
                        angleStep = baseSettings.MIN_ANGLE_BETWEEN_BRANCHES;
                    }
                    const startAngleOffset = (numBranches % 2 === 0) ? angleStep / 2 : 0;
                    mindMapData.branches.forEach((branch, index) => {
                        if (!branch || !branch.title || branch.title.trim() === '') return;
                        let angle = (index * angleStep) + startAngleOffset - (Math.PI / 2);
                        if (numBranches === 1) angle = -Math.PI / 2;
                        const branchRadius = baseSettings.LEVEL_DISTANCE_FACTOR * 0.9 + (Math.random() * 20 - 10);
                        const initialBranchX = centerX + Math.cos(angle) * branchRadius;
                        const initialBranchY = centerY + Math.sin(angle) * branchRadius;
                        calculateOrganicBranchPositionsRecursive(branch, initialBranchX, initialBranchY, 
                            targetNodePositionsMap.get(centralNodeId), 1, angle, index, centralNodeId, 
                            targetNodePositionsMap, baseSettings);
                    });
                }
                return targetNodePositionsMap;
            }
        }

        // Renamed from calculateBranchPositionsRecursive to be specific to organic layout
        function calculateOrganicBranchPositionsRecursive(branchData, initialX, initialY, parentNodeInfo, level, parentAngle, branchIndex, parentKey, targetNodePositionsMap, baseSettings) {
            const originalNodeText = branchData.title; 
            if (!originalNodeText || typeof originalNodeText !== 'string' || originalNodeText.trim() === "") return;
            const nodeKey = `node-org-${level}-${branchIndex}-${parentKey}-${Math.random().toString(36).substring(2, 7)}`;
            const metrics = calculateNodeMetrics(originalNodeText, level, false); 

            // Usa uma c√≥pia tempor√°ria do targetNodePositionsMap para checkCollision e adjustPosition
            // para evitar que o n√≥ atual colida consigo mesmo se j√° estiver no mapa (embora n√£o devesse estar aqui)
            const tempCollisionMap = new Map(targetNodePositionsMap);

            const { x: finalX, y: finalY } = adjustPositionInternal(initialX, initialY, metrics.width, metrics.height, nodeKey, tempCollisionMap, 60, 10);

            targetNodePositionsMap.set(nodeKey, {
                id: nodeKey, x: finalX, y: finalY, width: metrics.width, height: metrics.height,
                originalData: branchData, level: level, branchIndex: branchIndex, parentKey: parentKey,
                displayText: metrics.text, fontSize: metrics.fontSize, fontWeight: metrics.fontWeight
            });

            if (branchData.children && branchData.children.length > 0) {
                const numChildren = branchData.children.length;
                const maxSpread = Math.PI / (1.5 + level * 0.2);
                const minSpread = Math.PI / 8;
                let currentSpreadAngle = Math.max(minSpread, Math.min(maxSpread, Math.PI / (1.2 + level * 0.4 + Math.max(0, numChildren - 2) * 0.3)));
                if (numChildren === 1) currentSpreadAngle = 0;

                const childRadius = baseSettings.LEVEL_DISTANCE_FACTOR * Math.max(0.35, (0.75 - level * 0.12));

                branchData.children.forEach((child, childIdx) => {
                    if (!child || !child.title || child.title.trim() === '') return;

                    let childAngle;
                    if (numChildren === 1) {
                        childAngle = parentAngle;
                    } else {
                        childAngle = parentAngle - (currentSpreadAngle / 2) + (childIdx / (numChildren - 1)) * currentSpreadAngle;
                    }
                    const angleVariation = (Math.random() - 0.5) * (Math.PI / 18 / (level + 1));
                    childAngle += angleVariation;

                    const childInitialX = finalX + Math.cos(childAngle) * childRadius;
                    const childInitialY = finalY + Math.sin(childAngle) * childRadius;

                    calculateBranchPositionsRecursive(
                        child, 
                        childInitialX, 
                        childInitialY, 
                        targetNodePositionsMap.get(nodeKey), level + 1, childAngle, branchIndex, nodeKey, 
                        targetNodePositionsMap, baseSettings);
                });
            }
        }

        // Renomeado de checkCollisionInternal para evitar conflito e para ser usado internamente
        function checkCollisionInternal(x, y, width, height, positionsMap) {
            const R1 = { left: x - width / 2, right: x + width / 2, top: y - height / 2, bottom: y + height / 2 };
            for (let pos of positionsMap.values()) { // Usa o mapa passado como argumento
                const R2 = { left: pos.x - pos.width / 2, right: pos.x + pos.width / 2, top: pos.y - pos.height / 2, bottom: pos.y + pos.height / 2 };
                const buffer = 15; 
                if (R1.left < R2.right + buffer && R1.right + buffer > R2.left && 
                    R1.top < R2.bottom + buffer && R1.bottom + buffer > R2.top) {
                    return true;
                }
            }
            return false;
        }

        // Renomeado de adjustPosition para evitar conflito e para ser usado internamente
        function adjustPositionInternal(initialX, initialY, width, height, nodeKeyPrefix, positionsMap, maxAttempts = 60, stepSize = 10) {
            let currentX = initialX;
            let currentY = initialY;
            let attempt = 0;
            const initialStepRadius = stepSize; 

            // Usa checkCollisionInternal com o mapa de posi√ß√µes fornecido
            while (checkCollisionInternal(currentX, currentY, width, height, positionsMap) && attempt < maxAttempts) {
                attempt++;
                const angle = attempt * (Math.PI * (3 - Math.sqrt(5))); 
                const radius = initialStepRadius + (attempt * stepSize * 0.15); 
                currentX = initialX + Math.cos(angle) * radius;
                currentY = initialY + Math.sin(angle) * radius;
            }
            if (attempt >= maxAttempts) {
                console.warn(`N√£o foi poss√≠vel encontrar posi√ß√£o livre de colis√£o para ${nodeKeyPrefix} ap√≥s ${maxAttempts} tentativas. Usando √∫ltima posi√ß√£o tentada.`);
            }
            return { x: currentX, y: currentY };
        }

        // ==========================================================================================
        // HIERARCHICAL TOP-DOWN LAYOUT LOGIC
        // ==========================================================================================
        function calculateTopDownHierarchicalPositions(mindMapData, svgWidth, svgHeight, targetNodePositionsMap, baseSettings) {
            const centralNodeId = 'central-hier-td'; 
            const centralMetrics = calculateNodeMetrics(mindMapData.central, 0, true);
            const centralY = centralMetrics.height / 2 + baseSettings.HIERARCHICAL_LEVEL_GAP / 3; 

            const centralNodeMapEntry = {
                id: centralNodeId,
                x: 0, // Initial X is relative (0), will be globally shifted later.
                y: centralY,
                width: centralMetrics.width,
                height: centralMetrics.height,
                originalData: { title: mindMapData.central, children: mindMapData.branches },
                level: 0,
                branchIndex: 0, 
                parentKey: null,
                displayText: centralMetrics.text,
                fontSize: centralMetrics.fontSize,
                fontWeight: centralMetrics.fontWeight,
                subtreeWidth: 0, // To be calculated: total width of the subtree rooted here
                xOffsetInSubtree: 0 
            };
            targetNodePositionsMap.set(centralNodeId, centralNodeMapEntry);

            positionHierarchicalChildrenRecursiveTd(centralNodeMapEntry, targetNodePositionsMap, baseSettings); // TD specific
            
            const rootEntry = targetNodePositionsMap.get(centralNodeId);
            const globalShiftX = (svgWidth / 2) - rootEntry.xOffsetInSubtree;

            if (targetNodePositionsMap.size > 0) {
                 targetNodePositionsMap.forEach(node => node.x += globalShiftX);
            }
            return targetNodePositionsMap;
        }

        // Recursive helper for TOP-DOWN layout.
        function positionHierarchicalChildrenRecursiveTd(parentNodeMapEntry, targetNodePositionsMap, baseSettings) {
            const childrenData = parentNodeMapEntry.originalData.children;
            if (!childrenData || childrenData.length === 0) {
                parentNodeMapEntry.subtreeWidth = parentNodeMapEntry.width;
                parentNodeMapEntry.xOffsetInSubtree = parentNodeMapEntry.width / 2; 
                return;
            }
            const childMapEntries = [];
            let totalChildrenSubtreeWidthWithGaps = 0;
            childrenData.forEach((childData, index) => {
                const childMetrics = calculateNodeMetrics(childData.title, parentNodeMapEntry.level + 1, false);
                const childNodeId = `node-hier-td-${parentNodeMapEntry.id}-${index}`; 
                const childY = parentNodeMapEntry.y + parentNodeMapEntry.height / 2 + baseSettings.HIERARCHICAL_LEVEL_GAP + childMetrics.height / 2;
                const childMapEntry = {
                    id: childNodeId, x: 0, y: childY, width: childMetrics.width, height: childMetrics.height,
                    originalData: childData, level: parentNodeMapEntry.level + 1, branchIndex: index, parentKey: parentNodeMapEntry.id,
                    displayText: childMetrics.text, fontSize: childMetrics.fontSize, fontWeight: childMetrics.fontWeight,
                    subtreeWidth: 0, xOffsetInSubtree: 0 
                };
                targetNodePositionsMap.set(childNodeId, childMapEntry);
                childMapEntries.push(childMapEntry);
                positionHierarchicalChildrenRecursiveTd(childMapEntry, targetNodePositionsMap, baseSettings);
                totalChildrenSubtreeWidthWithGaps += childMapEntry.subtreeWidth;
            });
            totalChildrenSubtreeWidthWithGaps += Math.max(0, childMapEntries.length - 1) * baseSettings.HIERARCHICAL_SIBLING_GAP;
            parentNodeMapEntry.subtreeWidth = Math.max(parentNodeMapEntry.width, totalChildrenSubtreeWidthWithGaps);
            parentNodeMapEntry.xOffsetInSubtree = parentNodeMapEntry.subtreeWidth / 2; 
            let currentChildX = parentNodeMapEntry.x - totalChildrenSubtreeWidthWithGaps / 2;
            childMapEntries.forEach(childEntry => {
                childEntry.x = currentChildX + childEntry.xOffsetInSubtree;
                currentChildX += childEntry.subtreeWidth + baseSettings.HIERARCHICAL_SIBLING_GAP;
            });
        }

        // ==========================================================================================
        // HIERARCHICAL LEFT-RIGHT LAYOUT LOGIC
        // ==========================================================================================
        function calculateLeftRightHierarchicalPositions(mindMapData, svgWidth, svgHeight, targetNodePositionsMap, baseSettings) {
            const centralNodeId = 'central-hier-lr'; 
            const centralMetrics = calculateNodeMetrics(mindMapData.central, 0, true);
            const centralX = centralMetrics.width / 2 + baseSettings.HIERARCHICAL_LEVEL_GAP / 3; 
            
            const centralNodeMapEntry = {
                id: centralNodeId,
                x: centralX, 
                y: 0, 
                width: centralMetrics.width,
                height: centralMetrics.height,
                originalData: { title: mindMapData.central, children: mindMapData.branches },
                level: 0,
                branchIndex: 0, 
                parentKey: null,
                displayText: centralMetrics.text,
                fontSize: centralMetrics.fontSize,
                fontWeight: centralMetrics.fontWeight,
                subtreeHeight: 0, 
                yOffsetInSubtree: 0 
            };
            targetNodePositionsMap.set(centralNodeId, centralNodeMapEntry);

            positionHierarchicalChildrenRecursiveLr(centralNodeMapEntry, targetNodePositionsMap, baseSettings); 
            
            const rootEntry = targetNodePositionsMap.get(centralNodeId);
            const globalShiftY = (svgHeight / 2) - (rootEntry.y + rootEntry.yOffsetInSubtree - rootEntry.subtreeHeight/2) - rootEntry.subtreeHeight/2;
            // Simplified: const globalShiftY = (svgHeight / 2) - rootEntry.yOffsetInSubtree; if rootEntry.y is 0.

            if (targetNodePositionsMap.size > 0) {
                 targetNodePositionsMap.forEach(node => node.y += globalShiftY);
            }
            return targetNodePositionsMap;
        }

        function positionHierarchicalChildrenRecursiveLr(parentNodeMapEntry, targetNodePositionsMap, baseSettings) {
            const childrenData = parentNodeMapEntry.originalData.children;
            if (!childrenData || childrenData.length === 0) { 
                parentNodeMapEntry.subtreeHeight = parentNodeMapEntry.height;
                parentNodeMapEntry.yOffsetInSubtree = parentNodeMapEntry.height / 2; 
                return;
            }
            const childMapEntries = [];
            let totalChildrenSubtreeHeightWithGaps = 0;
            childrenData.forEach((childData, index) => {
                const childMetrics = calculateNodeMetrics(childData.title, parentNodeMapEntry.level + 1, false);
                const childNodeId = `node-hier-lr-${parentNodeMapEntry.id}-${index}`; 
                const childX = parentNodeMapEntry.x + parentNodeMapEntry.width / 2 + baseSettings.HIERARCHICAL_LEVEL_GAP + childMetrics.width / 2;
                const childMapEntry = {
                    id: childNodeId, x: childX, y: 0, 
                    width: childMetrics.width, height: childMetrics.height,
                    originalData: childData, level: parentNodeMapEntry.level + 1, branchIndex: index, parentKey: parentNodeMapEntry.id,
                    displayText: childMetrics.text, fontSize: childMetrics.fontSize, fontWeight: childMetrics.fontWeight,
                    subtreeHeight: 0, yOffsetInSubtree: 0 
                };
                targetNodePositionsMap.set(childNodeId, childMapEntry);
                childMapEntries.push(childMapEntry);
                positionHierarchicalChildrenRecursiveLr(childMapEntry, targetNodePositionsMap, baseSettings);
                totalChildrenSubtreeHeightWithGaps += childMapEntry.subtreeHeight;
            });
            totalChildrenSubtreeHeightWithGaps += Math.max(0, childMapEntries.length - 1) * baseSettings.HIERARCHICAL_SIBLING_GAP; 
            parentNodeMapEntry.subtreeHeight = Math.max(parentNodeMapEntry.height, totalChildrenSubtreeHeightWithGaps);
            parentNodeMapEntry.yOffsetInSubtree = parentNodeMapEntry.subtreeHeight / 2; 
            let currentChildY = parentNodeMapEntry.y - (totalChildrenSubtreeHeightWithGaps / 2); // Start Y for the first child's subtree block
            childMapEntries.forEach(childEntry => {
                childEntry.y = currentChildY + childEntry.yOffsetInSubtree; // Position child's center within its allocated slot
                currentChildY += childEntry.subtreeHeight + baseSettings.HIERARCHICAL_SIBLING_GAP;
            });
        }

        // ==========================================================================================
        // RENDERING LOGIC
        // ==========================================================================================
        function renderMindMap(data, svgWidth, svgHeight, layoutType = 'organic') { // Default to 'organic' if not provided
            svgElement = document.getElementById('mindMapSvg');
            rootGroup = document.getElementById('mindMapRootGroup');
            debugInfoElement = document.getElementById('debugInfo');
            rootGroup.innerHTML = ''; 
            
            const baseSettings = {
                LEVEL_DISTANCE_FACTOR, MIN_ANGLE_BETWEEN_BRANCHES, 
                HIERARCHICAL_LEVEL_GAP, HIERARCHICAL_SIBLING_GAP,
                NODE_PADDING, MAX_TEXT_LENGTH 
            };

            // TEMPORARY: Force hierarchical layout for testing the dispatcher
            // calculateNodePositions(data, 'default', svgWidth, svgHeight, nodePositions, baseSettings); 
            calculateNodePositions(data, 'hierarchical-top-down', svgWidth, svgHeight, nodePositions, baseSettings);


            svgElement.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            // Etapa 2: Renderizar os n√≥s
            nodePositions.forEach(nodeInfo => {
                // createNodeElement precisa de: text, x, y, level, branchIndex, isCentral
                const isCentral = (nodeInfo.level === 0);
                const nodeElementData = createNodeElement(
                    nodeInfo.displayText || nodeInfo.originalData.title, // Use displayText if available from nodePositions
                    nodeInfo.x, 
                    nodeInfo.y, 
                    nodeInfo.level, 
                    nodeInfo.branchIndex, 
                    isCentral
                );
                rootGroup.appendChild(nodeElementData.group);
            });
            
            // Etapa 3: Renderizar os links
            let linksGroup = document.getElementById('linksGroup');
            if (linksGroup) { // Clear old links if the group exists
                linksGroup.innerHTML = '';
            } else { // Create links group if it doesn't exist
                linksGroup = createSVGElement('g', { id: 'linksGroup' });
            }
            
            nodePositions.forEach(nodeInfo => {
                if (nodeInfo.parentKey) {
                    const parentNodeInfo = nodePositions.get(nodeInfo.parentKey);
                    if (parentNodeInfo) {
                        const link = createLinkElement(
                            parentNodeInfo.x, 
                            parentNodeInfo.y, 
                            nodeInfo.x, 
                            nodeInfo.y, 
                            nodeInfo.level,
                            nodeInfo.width / 2, 
                            nodeInfo.height / 2 
                        );
                        linksGroup.appendChild(link);
                    }
                }
            });
            
            // Ensure linksGroup is the first child of rootGroup to be drawn underneath nodes
            if (rootGroup.firstChild !== linksGroup) {
                rootGroup.insertBefore(linksGroup, rootGroup.firstChild);
            } else if (!rootGroup.firstChild && linksGroup.childNodes.length > 0) { 
                // If rootGroup was empty and links were added
                rootGroup.appendChild(linksGroup);
            }


            updateDebugInfo();
            resetViewHandler(); 
            setupSVGInteractions();
        }


        function calculateNodeMetrics(text, level, isCentral = false) {
            const displayText = truncateText(text, isCentral ? MAX_TEXT_LENGTH + 5 : MAX_TEXT_LENGTH);
            const fontSize = isCentral ? BASE_FONT_SIZE + 4 : BASE_FONT_SIZE + Math.max(0, 3 - level); // Mantido como estava
            const rectHeight = isCentral ? BASE_NODE_HEIGHT + 10 : BASE_NODE_HEIGHT + Math.max(0, (3 - level) * 4); // Mantido
            const fontWeight = isCentral ? '700' : (level === 1 ? '600' : '500'); 
            const tempTextElement = createSVGElement('text', { // Renamed to avoid conflict
                style: `font-size: ${fontSize}px; font-family: Poppins, sans-serif; font-weight: ${fontWeight}; visibility: hidden;`
            }, displayText);
            const currentSvgElement = svgElement || document.getElementById('mindMapSvg'); // Ensure svgElement is available
            let computedTextWidth = 0;
            if (currentSvgElement && typeof currentSvgElement.appendChild === 'function') {
                currentSvgElement.appendChild(tempTextElement);
                computedTextWidth = tempTextElement.getComputedTextLength();
                currentSvgElement.removeChild(tempTextElement);
            } else {
                // Fallback if SVG not ready for measurement (e.g. during initial load or if hidden)
                computedTextWidth = displayText.length * fontSize * 0.6; 
                console.warn("calculateNodeMetrics: svgElement not fully available for text measurement, using estimate.");
            }
            const rectWidth = Math.max(computedTextWidth + NODE_PADDING.x * 2, isCentral ? 100 : 70);
            return { width: rectWidth, height: rectHeight, text: displayText, fontSize, fontWeight };
        }

        // drawBranchRecursive foi substitu√≠do por calculateOrganicBranchPositionsRecursive (para l√≥gica)
        // e a renderiza√ß√£o de n√≥s/links em renderMindMap.

        function createSVGElement(tag, attributes = {}, textContent = null) {
            const tempText = createSVGElement('text', {
                style: `font-size: ${fontSize}px; font-family: Poppins, sans-serif; font-weight: ${fontWeight}; visibility: hidden;`
            }, displayText);

            let computedTextWidth = 0;
            // Garante que svgElement esteja dispon√≠vel para medi√ß√£o. Se n√£o, usa fallback.
            const currentSvgElement = svgElement || document.getElementById('mindMapSvg'); 
            if (currentSvgElement && typeof currentSvgElement.appendChild === 'function') {
                currentSvgElement.appendChild(tempText);
                computedTextWidth = tempText.getComputedTextLength();
                currentSvgElement.removeChild(tempText);
            } else {
                // Fallback aproximado se o SVG n√£o estiver dispon√≠vel para medi√ß√£o
                computedTextWidth = displayText.length * fontSize * 0.6; 
                console.warn("calculateNodeMetrics: svgElement n√£o est√° pronto para medir texto, usando estimativa.");
            }

            const rectWidth = Math.max(computedTextWidth + NODE_PADDING.x * 2, isCentral ? 100 : 70); // Mantido
            return { width: rectWidth, height: rectHeight, text: displayText, fontSize, fontWeight }; // Retorna tamb√©m o texto e estilo para consist√™ncia
        }

        // drawBranchRecursive foi substitu√≠do por calculateBranchPositionsRecursive (para l√≥gica)
        // e a renderiza√ß√£o de n√≥s/links em renderMindMap.

        function createSVGElement(tag, attributes = {}, textContent = null) {
            const element = document.createElementNS(SVG_NAMESPACE, tag);
            for (const attr in attributes) {
                element.setAttribute(attr, attributes[attr]);
            }
            if (textContent) {
                element.textContent = textContent;
            }
            return element;
        }

        function createNodeElement(text, x, y, level, branchIndex, isCentral = false) {
            // text (original), x, y, level, branchIndex, isCentral
            // As m√©tricas (width, height, displayText, fontSize, fontWeight) s√£o agora pr√©-calculadas
            // por calculateNodeMetrics e passadas atrav√©s do objeto nodeInfo em nodePositions.
            // No entanto, createNodeElement ainda precisa delas para criar os elementos.
            // Para manter a consist√™ncia, vamos recalcular ou usar as m√©tricas de calculateNodeMetrics.
            // Idealmente, calculateNodeMetrics √© a √∫nica fonte da verdade para as dimens√µes.

            const metrics = calculateNodeMetrics(text, level, isCentral);
            const displayText = metrics.text; // Texto truncado de calculateNodeMetrics
            const currentRectWidth = metrics.width;
            const currentRectHeight = metrics.height; 
            // fontSize and fontWeight from metrics are used below

            const group = createSVGElement('g', {
                class: 'node-group',
                transform: `translate(${x},${y})`
            });

            let colorIdx;
            const nodeColors = getCurrentNodeColors();
            if (isCentral) {
                colorIdx = 0; // N√≥ central usa a primeira cor
            } else {
                // Para ramos, usa as cores restantes de forma c√≠clica
                colorIdx = (branchIndex % (nodeColors.length - 1)) + 1; 
                if (colorIdx >= nodeColors.length) colorIdx = 1; // Garante que n√£o ultrapasse o array
            }
            const fillColor = nodeColors[colorIdx % nodeColors.length];

            const rect = createSVGElement('rect', {
                class: 'node-rect',
                x: -currentRectWidth / 2,
                y: -currentRectHeight / 2,
                width: currentRectWidth,
                height: currentRectHeight,
                rx: level < 2 ? 12 : 8, // Borda mais arredondada para n√≥s de alto n√≠vel
                ry: level < 2 ? 12 : 8,
                style: `fill: ${fillColor}; stroke: ${shadeColor(fillColor, -25)}; stroke-width: 1.5px;`
            });

            const textElement = createSVGElement('text', {
                class: 'node-text',
                'font-size': metrics.fontSize, 
                'font-weight': metrics.fontWeight, 
                style: `fill: var(--node-text-color);` 
            }, metrics.text); // Use displayText from metrics
            group.dataset.fullText = text; // Store original, non-truncated text

            group.appendChild(rect);
            group.appendChild(textElement);
            return { group, width: currentRectWidth, height: currentRectHeight };
        }

        function shadeColor(color, percent) { // Utility para escurecer/clarear cores
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  

            R = Math.max(0,R);
            G = Math.max(0,G);
            B = Math.max(0,B);

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return `#${RR}${GG}${BB}`;
        }

        function createLinkElement(x1, y1, x2, y2, level, targetNodeHalfWidth, targetNodeHalfHeight) {
            const path = createSVGElement('path', { 
                class: 'link-path',
                'marker-end': 'url(#arrowhead)' // Adiciona a seta no final do link
            });

            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Ajusta o ponto final do link para parar antes de entrar no n√≥
            let ratio = 0.9; 
            if (distance > 0) {
                const angleToTarget = Math.atan2(dy, dx);
                // Calcula a intersec√ß√£o com um ret√¢ngulo (aproxima√ß√£o para o n√≥)
                let intersectDist = Math.min(
                    Math.abs(targetNodeHalfWidth / Math.cos(angleToTarget || 1e-9)), 
                    Math.abs(targetNodeHalfHeight / Math.sin(angleToTarget || 1e-9))  
                );
                intersectDist = Math.min(intersectDist, distance * 0.8); // Limita a intersec√ß√£o para n√£o ir muito longe
                ratio = (distance - intersectDist - 4) / distance; // Subtrai mais um pouco para a seta e buffer
            }

            const adjustedX2 = x1 + dx * ratio;
            const adjustedY2 = y1 + dy * ratio;

            // Pontos de controle para uma curva suave
            const midX = (x1 + adjustedX2) / 2;
            const midY = (y1 + adjustedY2) / 2;
            const controlOffset = distance * 0.20 * (level % 2 === 0 ? 1 : -0.7); // Varie a curva
            const controlX = midX + (dy / (distance || 1)) * controlOffset; 
            const controlY = midY - (dx / (distance || 1)) * controlOffset; 

            path.setAttribute('d', `M ${x1} ${y1} Q ${controlX} ${controlY} ${adjustedX2} ${adjustedY2}`);

            const nodeColors = getCurrentNodeColors();
            path.style.stroke = shadeColor(nodeColors[(level) % nodeColors.length], currentTheme === 'light' ? -15 : 15); 
            return path;
        }

        function setupSVGInteractions() {
            if (!svgElement) svgElement = document.getElementById('mindMapSvg');
            svgElement.addEventListener('mousedown', onPointerDown);
            svgElement.addEventListener('mousemove', onPointerMove);
            svgElement.addEventListener('mouseup', onPointerUp);
            svgElement.addEventListener('mouseleave', onPointerUp); 
            svgElement.addEventListener('wheel', onWheelScroll, { passive: false }); // Desabilita scroll padr√£o
            svgElement.addEventListener('touchstart', onPointerDown, { passive: false });
            svgElement.addEventListener('touchmove', onPointerMove, { passive: false });
            svgElement.addEventListener('touchend', onPointerUp);
            svgElement.addEventListener('touchcancel', onPointerUp);
        }

        function getPointerCoordinates(event) {
            if (event.touches && event.touches.length > 0) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function onPointerDown(e) {
            e.preventDefault(); 
            isDragging = true;
            const coords = getPointerCoordinates(e);
            lastPointerX = coords.x;
            lastPointerY = coords.y;
            svgElement.style.cursor = 'grabbing';
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const coords = getPointerCoordinates(e);
            const deltaX = coords.x - lastPointerX;
            const deltaY = coords.y - lastPointerY;
            currentTranslateX += deltaX;
            currentTranslateY += deltaY;
            updateTransform();
            lastPointerX = coords.x;
            lastPointerY = coords.y;
        }

        function onPointerUp() {
            if (isDragging) {
                isDragging = false;
                svgElement.style.cursor = 'grab';
            }
        }

        function onWheelScroll(e) {
            e.preventDefault(); 
            const delta = e.deltaY > 0 ? 0.85 : 1.15; // Fator de zoom
            const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentScale * delta)); 

            const svgRect = svgElement.getBoundingClientRect();
            const pointerX = e.clientX - svgRect.left; 
            const pointerY = e.clientY - svgRect.top;  

            // Ajusta a transla√ß√£o para que o zoom seja no ponto do mouse
            currentTranslateX = pointerX - (pointerX - currentTranslateX) * (newScale / currentScale);
            currentTranslateY = pointerY - (pointerY - currentTranslateY) * (newScale / currentScale);
            currentScale = newScale;
            updateTransform();
        }

        function updateTransform() {
            if (!rootGroup) rootGroup = document.getElementById('mindMapRootGroup');
            rootGroup.setAttribute('transform', `translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})`);
            updateDebugInfo();
        }

        function zoomHandler(zoomFactor) {
            const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentScale * zoomFactor));
            if (newScale === currentScale) return; 

            const svgRect = svgElement.getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;

            // Zoom no centro do SVG
            currentTranslateX = centerX - (centerX - currentTranslateX) * (newScale / currentScale);
            currentTranslateY = centerY - (centerY - currentTranslateY) * (newScale / currentScale);
            currentScale = newScale;
            updateTransform();
        }

        function zoomInHandler() { zoomHandler(1.25); }
        function zoomOutHandler() { zoomHandler(0.8); }

        function resetViewHandler() {
            const svgWidth = mindMapContainerElement.clientWidth;
            const svgHeight = mindMapContainerElement.clientHeight;

            currentScale = 1; 
            currentTranslateX = 0; 
            currentTranslateY = 0;

            if (rootGroup && typeof rootGroup.getBBox === 'function' && rootGroup.childNodes.length > 0) {
                try {
                    const contentBBox = rootGroup.getBBox();
                    // Verifica se o bounding box √© v√°lido (n√£o zero ou infinito)
                    if (contentBBox.width > 0 && contentBBox.height > 0 && isFinite(contentBBox.x) && isFinite(contentBBox.y)) {
                        const scaleToFitWidth = svgWidth / contentBBox.width;
                        const scaleToFitHeight = svgHeight / contentBBox.height;
                        // Escolhe a menor escala para garantir que todo o conte√∫do seja vis√≠vel
                        currentScale = Math.min(scaleToFitWidth, scaleToFitHeight) * 0.90; // 90% para uma margem
                        currentScale = Math.max(MIN_ZOOM, Math.min(1.2, currentScale)); // Limita o zoom m√°ximo para n√£o ficar muito grande

                        // Calcula a transla√ß√£o para centralizar o conte√∫do
                        currentTranslateX = (svgWidth / 2) - (contentBBox.x + contentBBox.width / 2) * currentScale;
                        currentTranslateY = (svgHeight / 2) - (contentBBox.y + contentBBox.height / 2) * currentScale;
                    } else { 
                        console.warn("BBox do conte√∫do √© inv√°lido. Resetando para valores padr√£o.");
                    }
                } catch (e) { 
                    console.warn("Erro ao calcular BBox para recentralizar:", e);
                }
            } else { 
                 console.log("Root group ou child nodes n√£o dispon√≠veis para calcular BBox. Resetando para padr√£o.");
            }
            updateTransform();
        }

        function updateDebugInfo() {
            if (debugInfoElement) {
                 debugInfoElement.style.display = 'block';
                 debugInfoElement.innerHTML = `
                    Scale: ${currentScale.toFixed(2)}<br>
                    TX: ${currentTranslateX.toFixed(0)}px, TY: ${currentTranslateY.toFixed(0)}px<br>
                    Nodes: ${nodePositions.size}
                `;
            }
        }

        function showLoading(show) {
            loadingElement.style.display = show ? 'block' : 'none';
            generateMapButton.disabled = show; // Desabilita o bot√£o enquanto carrega
            exportPngButtonElement.disabled = show || !rootGroup.dataset.mindmapData; // Desabilita tamb√©m o exportar
            textInputElement.disabled = show;
        }
        function showError(message) {
            errorContainerElement.innerHTML = `<div class="error-message">${message}</div>`;
        }
        function clearError() {
            errorContainerElement.innerHTML = '';
        }
        function clearAll() {
            textInputElement.value = '';
            mindMapContainerElement.classList.add('hidden');
            if (rootGroup) rootGroup.innerHTML = '';
            if (debugInfoElement) debugInfoElement.style.display = 'none';
            nodePositions.clear();
            clearError();
            currentScale = 1;
            currentTranslateX = 0;
            currentTranslateY = 0;
            updateTransform();
            if (exportPngButtonElement) exportPngButtonElement.disabled = true;
            if (rootGroup) rootGroup.dataset.mindmapData = ''; // Limpa os dados do mapa
        }

        function askAndSetApiKey() {
            // Tenta buscar a chave da API do localStorage primeiro
            let storedKey = localStorage.getItem('geminiApiKey');
            userApiKey = prompt("Por favor, insira a sua chave da API Gemini para utilizar a aplica√ß√£o:", storedKey || "");
            
            if (!userApiKey || userApiKey.trim() === "") {
                showError("Chave da API n√£o fornecida. A gera√ß√£o de mapas mentais est√° desativada. Recarregue a p√°gina para tentar novamente.");
                if(generateMapButton) generateMapButton.disabled = true;
                if(exportPngButtonElement) exportPngButtonElement.disabled = true;
            } else {
                 localStorage.setItem('geminiApiKey', userApiKey); // Salva a chave no localStorage
                 if(generateMapButton) generateMapButton.disabled = false;
                 if(exportPngButtonElement) exportPngButtonElement.disabled = true; 
                 clearError(); 
            }
        }

        // Atalho Ctrl+Enter para gerar o mapa mental
        textInputElement.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault(); 
                generateMindMap();
            }
        });

        // Inicializa√ß√£o da aplica√ß√£o
        document.addEventListener('DOMContentLoaded', () => {
            svgElement = document.getElementById('mindMapSvg');
            rootGroup = document.getElementById('mindMapRootGroup');
            debugInfoElement = document.getElementById('debugInfo');
            generateMapButton = document.getElementById('generateMapBtn');
            exportPngButtonElement = document.getElementById('exportPngBtn');
            
            // Cria e adiciona o toggle de tema
            emojiThemeToggleElement = document.createElement('div'); 
            emojiThemeToggleElement.id = 'emojiThemeToggle';
            const headerElement = document.querySelector('.header');
            if (headerElement) {
                headerElement.appendChild(emojiThemeToggleElement);
            } else {
                console.error("Elemento .header n√£o encontrado para adicionar o seletor de tema emoji.");
            }
            emojiThemeToggleElement.textContent = currentTheme === 'light' ? '‚òÄÔ∏è' : 'üåô'; 
            emojiThemeToggleElement.onclick = toggleTheme; 

            // Adiciona o listener para o bot√£o de exportar
            if (exportPngButtonElement) {
                exportPngButtonElement.addEventListener('click', exportMindMapAsPng);
            } else {
                console.error("Bot√£o de exportar PNG n√£o encontrado.");
            }

            askAndSetApiKey(); // Solicita a chave da API ao carregar

            if (!svgElement || !rootGroup) {
                console.error("Elementos SVG principais n√£o encontrados!");
            } else {
                 setupSVGInteractions(); // Configura intera√ß√µes de pan e zoom
                 resetViewHandler(); // Garante que o SVG esteja em estado inicial
            }
        });

    </script>
</body>
</html>