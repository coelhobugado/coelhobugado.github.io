<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Mapas Mentais Tradicionais com IA</title>
    <script src="https://cdn.jsdelivr.net/npm/save-svg-as-png@1.4.17/lib/saveSvgAsPng.min.js"></script>
    <style>
        :root {
            --primary-color: #5b86e5;
            --secondary-color: #36d1dc;
            --light-bg: #fdfdff;
            --text-color: #333;
            --node-text-color: white;
            --border-radius: 10px;
            --shadow: 0 6px 20px rgba(0,0,0,0.1);

            /* Cores para o tema claro (padr√£o) */
            --body-bg: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            --container-header-text-color: white;
            --input-section-bg: white;
            --input-label-color: #555;
            --textarea-border-color: #e0e0e0;
            --textarea-focus-border-color: var(--primary-color);
            --textarea-focus-shadow-color: rgba(91, 134, 229, 0.25);
            --btn-secondary-bg: #f5f5f5;
            --btn-secondary-text-color: var(--text-color);
            --btn-secondary-border-color: #ddd;
            --btn-secondary-hover-bg: #e8e8e8;
            --btn-secondary-hover-border-color: #ccc;
            --loading-text-color: white;
            --mindmap-container-bg: var(--light-bg);
            --mindmap-svg-bg: #ffffff;
            --control-btn-bg: rgba(0,0,0,0.7);
            --control-btn-hover-bg: rgba(0,0,0,0.85);
            --debug-info-bg: rgba(40,40,40,0.8);
            --debug-info-text-color: #f0f0f0;
            --error-message-bg: #fff0f0;
            --error-message-text-color: #d32f2f;
            --error-message-border-color: #ffcdd2;
            --link-path-stroke-default: #777; /* Cor base para links no tema claro */
        }

        .dark-theme {
            --primary-color: #7A86B6; /* Roxo acinzentado */
            --secondary-color: #4A5568; /* Cinza azulado escuro */
            --light-bg: #2d3748;    /* Cinza muito escuro para fundos principais */
            --text-color: #e2e8f0;   /* Cinza claro para texto geral */
            --node-text-color: #f7fafc; /* Branco quase puro para texto do n√≥ */

            --body-bg: linear-gradient(135deg, #2c3e50 0%, #1f2937 100%);
            --container-header-text-color: #e2e8f0;
            --input-section-bg: #2d3748; /* Cinza escuro para se√ß√µes de input */
            --input-label-color: #a0aec0; /* Cinza m√©dio para labels */
            --textarea-border-color: #4a5568; /* Cinza mais escuro para bordas */
            --textarea-focus-border-color: var(--primary-color);
            --textarea-focus-shadow-color: rgba(122, 134, 182, 0.3);
            --btn-secondary-bg: #4a5568;
            --btn-secondary-text-color: #e2e8f0;
            --btn-secondary-border-color: #718096;
            --btn-secondary-hover-bg: #2d3748;
            --btn-secondary-hover-border-color: #a0aec0;
            --loading-text-color: #e2e8f0;
            --mindmap-container-bg: #1a202c; /* Fundo bem escuro para o container do mapa */
            --mindmap-svg-bg: #283141; /* Fundo escuro para o SVG */
            --control-btn-bg: rgba(255,255,255,0.15);
            --control-btn-hover-bg: rgba(255,255,255,0.25);
            --debug-info-bg: rgba(20,20,20,0.85);
            --debug-info-text-color: #cbd5e0;
            --error-message-bg: #4a2426; /* Vermelho escuro para fundo de erro */
            --error-message-text-color: #feb2b2; /* Vermelho claro para texto de erro */
            --error-message-border-color: #c53030; /* Vermelho para borda de erro */
            --link-path-stroke-default: #9eadbf; /* Cor base para links no tema escuro */
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--body-bg);
            min-height: 100vh;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow-x: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px; 
            width: 95%;
            margin: 0 auto;
            padding: 15px;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            color: var(--container-header-text-color);
            position: relative; /* Added for positioning context for the emoji toggle */
        }

        #emojiThemeToggle {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8rem; /* Larger emoji */
            cursor: pointer;
            padding: 5px;
            user-select: none; /* Prevent text selection */
            transition: transform 0.2s ease;
        }
        #emojiThemeToggle:hover {
            transform: scale(1.15);
        }

        .header h1 {
            font-size: 2.3rem;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.15);
        }

        .header p {
            font-size: 1rem;
            opacity: 0.95;
        }

        .input-section {
            background: var(--input-section-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--shadow);
            transition: background 0.3s ease;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--input-label-color);
            transition: color 0.3s ease;
        }

        textarea {
            width: 100%;
            padding: 14px;
            border: 1px solid var(--textarea-border-color);
            border-radius: 8px;
            font-size: 0.95rem;
            font-family: 'Poppins', sans-serif;
            resize: vertical;
            min-height: 120px; 
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
            background-color: var(--input-section-bg); 
            color: var(--text-color); 
        }

        textarea:focus {
            outline: none;
            border-color: var(--textarea-focus-border-color);
            box-shadow: 0 0 0 2.5px var(--textarea-focus-shadow-color);
        }

        .button-group {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 11px 25px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.25s ease;
            letter-spacing: 0.3px;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }


        .btn-primary {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white; 
            box-shadow: 0 3px 12px rgba(0,0,0,0.1);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 18px rgba(91, 134, 229, 0.35);
        }

        .btn-secondary {
            background: var(--btn-secondary-bg);
            color: var(--btn-secondary-text-color);
            border: 1px solid var(--btn-secondary-border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--btn-secondary-hover-bg);
            border-color: var(--btn-secondary-hover-border-color);
        }

        .theme-toggle-btn {
        }


        .loading {
            display: none;
            text-align: center;
            padding: 25px;
            color: var(--loading-text-color);
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.25);
            border-radius: 50%;
            border-top: 4px solid var(--container-header-text-color); 
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mindmap-container {
            background: var(--mindmap-container-bg);
            border-radius: var(--border-radius);
            padding: 10px;
            box-shadow: var(--shadow);
            min-height: 600px; 
            height: 70vh; 
            overflow: hidden;
            position: relative;
            transition: background 0.3s ease;
        }

        .mindmap-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            border: none;
            background: var(--control-btn-bg);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; 
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25); 
        }

        .control-btn:hover {
            background: var(--control-btn-hover-bg);
            transform: scale(1.1);
        }

        #mindMapSvg {
            width: 100%;
            height: 100%;
            cursor: grab;
            background-color: var(--mindmap-svg-bg);
            border-radius: calc(var(--border-radius) - 4px);
            transition: background-color 0.3s ease;
        }

        #mindMapSvg:active {
            cursor: grabbing;
        }

        .node-group .node-rect {
            stroke-width: 2px; 
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.15)); 
            transition: filter 0.2s ease, transform 0.2s ease, fill 0.3s ease, stroke 0.3s ease;
        }

        .node-group:hover .node-rect {
             filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.25));
             transform: translateY(-1px) scale(1.02); 
        }

        .node-text {
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: var(--node-text-color);
            transition: fill 0.3s ease;
        }

        .link-path {
            stroke-opacity: 0.7;
            stroke-width: 2.5px; 
            fill: none;
            transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease, stroke 0.3s ease;
        }

        .link-path:hover { 
            stroke-opacity: 1;
            stroke-width: 3.5px;
        }

        .error-message { 
            background: var(--error-message-bg);
            color: var(--error-message-text-color);
            border: 1px solid var(--error-message-border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 0.9rem;
            transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        .hidden {
            display: none !important; 
        }

        .debug-info {
            position: absolute;
            top: 12px;
            left: 12px;
            background: var(--debug-info-bg); 
            color: var(--debug-info-text-color);
            padding: 10px;
            border-radius: 6px;
            font-size: 11px; 
            font-family: monospace;
            z-index: 1001;
            opacity: 0.9;
            display: none; 
            transition: background 0.3s ease, color 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Gerador de Mapas Mentais</h1>
            <p>Visualize suas ideias com mapas mentais criados por IA</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="textInput">Insira o texto base para o seu mapa mental:</label>
                <textarea id="textInput" placeholder="Ex: Planejamento de um projeto, resumo de um livro, ideias para um novo neg√≥cio..."></textarea>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="generateMapBtn" onclick="generateMindMap()">üí° Gerar Mapa Mental</button>
                <button class="btn-secondary" onclick="clearAll()">üóëÔ∏è Limpar Tudo</button>
                <button class="btn-secondary" id="exportPngBtn" disabled>üñºÔ∏è Exportar PNG</button> <!-- Adicionado disabled -->
                <!-- Bot√£o de tema removido daqui -->
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Criando seu mapa mental...</p>
        </div>

        <div id="errorContainer"></div> 
        <div class="mindmap-container hidden" id="mindMapContainer">
            <div class="debug-info" id="debugInfo"></div>
            <div class="mindmap-controls">
                <button class="control-btn" onclick="zoomInHandler()" title="Aproximar Zoom">+</button>
                <button class="control-btn" onclick="zoomOutHandler()" title="Afastar Zoom">-</button>
                <button class="control-btn" onclick="resetViewHandler()" title="Recentralizar">üéØ</button>
            </div>
            <svg id="mindMapSvg">
                <defs>
                    <marker id="arrowhead" markerWidth="8" markerHeight="6" 
                            refX="7" refY="3" orient="auto-start-reverse">
                        <polygon points="0 0, 8 3, 0 6" fill="#777" />
                    </marker>
                </defs>
                <g id="mindMapRootGroup"></g>
            </svg>
        </div>
    </div>

    <script>
        let userApiKey = null; // Chave API ser√° fornecida pelo utilizador
        const GEMINI_MODEL_NAME = "gemini-2.0-flash"; 

        const SVG_NAMESPACE = "http://www.w3.org/2000/svg";

        const NODE_COLORS_LIGHT = ['#5b86e5', '#45b6fe', '#36d1dc', '#f09819', '#cb356b', '#9b59b6', '#2ecc71', '#e74c3c'];
        const NODE_COLORS_DARK = ['#7A86B6', '#5C9EBF', '#4A7F83', '#D4882C', '#B04E5D', '#8A6AA1', '#3E8E41', '#C0392B'];

        const NODE_PADDING = { x: 20, y: 12 };
        const BASE_NODE_HEIGHT = 45;
        const BASE_FONT_SIZE = 12;
        const LEVEL_DISTANCE_FACTOR = 200; 
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 3; 
        const MAX_TEXT_LENGTH = 30; 
        const MIN_ANGLE_BETWEEN_BRANCHES = Math.PI / 7; 

        let svgElement, rootGroup, debugInfoElement, generateMapButton, emojiThemeToggleElement, exportPngButtonElement; // exportPngButtonElement adicionado
        let currentScale = 1;
        let currentTranslateX = 0;
        let currentTranslateY = 0;
        let isDragging = false;
        let lastPointerX = 0;
        let lastPointerY = 0;
        let nodePositions = new Map(); 
        let currentTheme = 'light';

        const textInputElement = document.getElementById('textInput');
        const loadingElement = document.getElementById('loading');
        const mindMapContainerElement = document.getElementById('mindMapContainer');
        const errorContainerElement = document.getElementById('errorContainer');

        function getCurrentNodeColors() {
            return currentTheme === 'light' ? NODE_COLORS_LIGHT : NODE_COLORS_DARK;
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.classList.toggle('dark-theme', currentTheme === 'dark');
            // Atualiza o emoji do novo controle de tema
            if (emojiThemeToggleElement) {
                emojiThemeToggleElement.textContent = currentTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
            }

            if (rootGroup && rootGroup.dataset.mindmapData) {
                 const currentData = JSON.parse(rootGroup.dataset.mindmapData);
                 if (currentData.central) {
                    renderMindMap(currentData, mindMapContainerElement.clientWidth, mindMapContainerElement.clientHeight);
                 }
            }
        }

        function exportMindMapAsPng() {
            const svgToExport = document.getElementById('mindMapSvg');
            if (!svgToExport) {
                showError("Elemento SVG do mapa mental n√£o encontrado para exporta√ß√£o.");
                return;
            }

            let filename = "mapa_mental.png";
            try {
                // Tenta obter um nome mais descritivo do n√≥ central, se existir
                if (rootGroup && rootGroup.dataset.mindmapData) { // Verifica se rootGroup e o dataset existem
                    const mindMapData = JSON.parse(rootGroup.dataset.mindmapData);
                    if (mindMapData && mindMapData.central) {
                        const centralTitle = mindMapData.central.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                        if (centralTitle) {
                            filename = `${centralTitle.substring(0, 50)}_mapa_mental.png`;
                        }
                    }
                }
            } catch (e) {
                console.warn("N√£o foi poss√≠vel obter o t√≠tulo do mapa para o nome do arquivo, usando padr√£o.", e);
            }

            const options = {
                backgroundColor: 'white', 
                scale: 2, 
                encoderOptions: 0.92,
            };

            console.log(`Tentando exportar SVG como PNG: ${filename} com op√ß√µes:`, options);

            if (typeof window.saveSvgAsPng !== 'undefined' && typeof window.saveSvgAsPng.saveSvgAsPng === 'function') {
                try {
                    window.saveSvgAsPng.saveSvgAsPng(svgToExport, filename, options);
                    console.log("Tentativa de exporta√ß√£o PNG iniciada para:", filename);
                } catch (error) {
                    console.error("Erro durante a chamada de saveSvgAsPng:", error);
                    showError(`Erro ao tentar exportar PNG: ${error.message}`);
                }
            } else {
                console.error("Biblioteca saveSvgAsPng n√£o carregada ou fun√ß√£o saveSvgAsPng n√£o encontrada.");
                showError("Erro: A biblioteca de exporta√ß√£o PNG n√£o foi carregada corretamente. Verifique sua conex√£o ou tente recarregar a p√°gina.");
            }
        }

        function truncateText(text, maxLength = MAX_TEXT_LENGTH) {
            if (!text || typeof text !== 'string') return 'Sem T√≠tulo';
            text = text.trim();
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength - 3) + '...';
        }

        function checkCollision(x, y, width, height) {
            const R1 = { left: x - width / 2, right: x + width / 2, top: y - height / 2, bottom: y + height / 2 };
            for (let pos of nodePositions.values()) {
                const R2 = { left: pos.x - pos.width / 2, right: pos.x + pos.width / 2, top: pos.y - pos.height / 2, bottom: pos.y + pos.height / 2 };
                const buffer = 10; 
                if (R1.left < R2.right + buffer && R1.right + buffer > R2.left && 
                    R1.top < R2.bottom + buffer && R1.bottom + buffer > R2.top) {
                    return true;
                }
            }
            return false;
        }

        function adjustPosition(initialX, initialY, width, height, nodeKeyPrefix, maxAttempts = 40, stepSize = 10) {
            let currentX = initialX;
            let currentY = initialY;
            let attempt = 0;
            const initialStepRadius = stepSize; 

            while (checkCollision(currentX, currentY, width, height) && attempt < maxAttempts) {
                attempt++;
                const angle = attempt * (Math.PI * 0.618034); 
                const radius = initialStepRadius + (attempt * stepSize * 0.15); 
                currentX = initialX + Math.cos(angle) * radius;
                currentY = initialY + Math.sin(angle) * radius;
            }
            if (attempt >= maxAttempts) {
                console.warn(`N√£o foi poss√≠vel encontrar posi√ß√£o livre de colis√£o para ${nodeKeyPrefix} ap√≥s ${maxAttempts} tentativas. Usando √∫ltima posi√ß√£o tentada.`);
            }
            return { x: currentX, y: currentY };
        }

        async function generateMindMap() {
            if (!userApiKey) {
                showError('Chave da API Gemini n√£o fornecida. Por favor, recarregue a p√°gina e insira a chave.');
                return;
            }

            const textInput = textInputElement.value.trim();
            if (!textInput) {
                showError('Por favor, insira um texto para gerar o mapa mental.');
                return;
            }
            if (textInput.length < 20) {
                showError('O texto precisa ter pelo menos 20 caracteres para gerar um mapa mental √∫til.');
                return;
            }

            showLoading(true);
            clearError(); 
            mindMapContainerElement.classList.add('hidden'); 
            nodePositions.clear();

            try {
                const apiResponse = await callGeminiAPI(textInput);
                console.log("Resposta da API Gemini (Mapa Mental):", JSON.stringify(apiResponse, null, 2));

                if (rootGroup) {
                    rootGroup.dataset.mindmapData = JSON.stringify(apiResponse);
                }

                if (apiResponse && apiResponse.central && validateMindMapStructure(apiResponse)) {
                    mindMapContainerElement.classList.remove('hidden');
                    await new Promise(resolve => requestAnimationFrame(resolve));

                    const svgWidth = mindMapContainerElement.clientWidth;
                    const svgHeight = mindMapContainerElement.clientHeight;

                    if (svgWidth > 0 && svgHeight > 0) {
                       renderMindMap(apiResponse, svgWidth, svgHeight);
                       // Habilitar bot√£o de exportar PNG ap√≥s renderiza√ß√£o bem-sucedida
                       if (exportPngButtonElement) exportPngButtonElement.disabled = false;
                    } else {
                       showError('Falha ao obter dimens√µes do container do mapa.');
                       mindMapContainerElement.classList.add('hidden');
                       if (exportPngButtonElement) exportPngButtonElement.disabled = true;
                    }
                } else {
                    showError('A IA n√£o retornou uma estrutura de mapa mental v√°lida ou completa. Tente novamente com um texto mais detalhado, ou ajuste o prompt na API.');
                    mindMapContainerElement.classList.add('hidden');
                    if (exportPngButtonElement) exportPngButtonElement.disabled = true;
                }
            } catch (error) {
                console.error("Erro em generateMindMap:", error);
                showError(`Erro ao gerar mapa mental: ${error.message}`);
                mindMapContainerElement.classList.add('hidden');
                if (exportPngButtonElement) exportPngButtonElement.disabled = true;
            } finally {
                showLoading(false);
            }
        }

        function validateMindMapStructure(data) {
            if (!data.central || typeof data.central !== 'string' || data.central.trim() === '') {
                console.warn("Valida√ß√£o falhou: T√≥pico central ausente ou inv√°lido.");
                return false;
            }
            if (!data.branches || !Array.isArray(data.branches)) { 
                 console.warn("Valida√ß√£o: Sem ramos principais, mas t√≥pico central existe. Permitindo.");
                 data.branches = []; 
                 return true; 
            }
            if (data.branches.length > 0) {
                const validBranches = data.branches.filter(branch => 
                    branch && typeof branch.title === 'string' && branch.title.trim() !== ''
                );
                if (validBranches.length < data.branches.length * 0.5 && data.branches.length > 1) { 
                    console.warn("Valida√ß√£o falhou: Muitos ramos sem t√≠tulo v√°lido.");
                    return false;
                }
            }
            return true;
        }

        async function callGeminiAPI(text) {
            if (!userApiKey) {
                 throw new Error("Chave da API Gemini n√£o est√° definida.");
            }
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent?key=${userApiKey}`;

            const prompt = \`
Analise o seguinte texto e crie uma estrutura de MAPA MENTAL hier√°rquica bem organizada em formato JSON.

INSTRU√á√ïES IMPORTANTES:
1. Crie entre 3 a 7 ramos principais (branches) originados do "central".
2. Cada "title" (tanto para "central" quanto para ramos/filhos) deve ter no m√°ximo ${MAX_TEXT_LENGTH} caracteres.
3. Cada ramo principal ("branches") deve ter, idealmente, entre 1 a 4 "children" (sub-ramos). Se n√£o houver sub-ramos, omita "children" ou use um array vazio.
4. Evite "children" de "children" (netos) com mais de 1 n√≠vel de profundidade, ou seja, no m√°ximo Central -> Ramo -> Filho -> Neto. O ideal √© Central -> Ramo -> Filho.
5. Use t√≠tulos claros, concisos e espec√≠ficos para cada n√≥.
6. Distribua as informa√ß√µes de forma equilibrada entre os ramos.
7. O t√≥pico "central" deve ser o conceito mais importante ou o t√≠tulo do texto.

ESTRUTURA JSON ESPERADA:
{
  "central": "T√≥pico Principal (m√°x ${MAX_TEXT_LENGTH} chars)",
  "branches": [
    {
      "title": "Ramo 1 (m√°x ${MAX_TEXT_LENGTH} chars)",
      "children": [
        { "title": "Sub-ramo 1.1 (m√°x ${MAX_TEXT_LENGTH} chars)" },
        { "title": "Sub-ramo 1.2 (m√°x ${MAX_TEXT_LENGTH} chars)", "children": [{ "title": "Neto 1.2.1 (m√°x ${MAX_TEXT_LENGTH} chars)" }] }
      ]
    },
    { "title": "Ramo 2 (m√°x ${MAX_TEXT_LENGTH} chars)" }
  ]
}

REGRAS OBRIGAT√ìRIAS PARA O JSON DE SA√çDA:
- A propriedade "central" DEVE existir e ser uma string n√£o vazia.
- A propriedade "branches" DEVE existir e ser um array (pode ser vazio se n√£o houver ramos).
- Cada objeto dentro de "branches" (e dentro de "children" recursivamente) DEVE ter uma propriedade "title" (string n√£o vazia).
- Todos os textos de "title" e "central" N√ÉO DEVEM exceder ${MAX_TEXT_LENGTH} caracteres.
- Retorne APENAS o JSON v√°lido, sem NENHUM texto explicativo, markdown, ou qualquer caractere fora do objeto JSON.

Texto para an√°lise:
${text}
\`;
            const grandChildItemSchema = {
                type: "OBJECT",
                properties: { "title": { type: "STRING" } },
                required: ["title"]
            };

            const childItemSchema = {
                type: "OBJECT",
                properties: {
                    "title": { type: "STRING" },
                    "children": { type: "ARRAY", items: grandChildItemSchema }
                },
                required: ["title"]
            };

            const branchItemSchema = {
                type: "OBJECT",
                properties: {
                    "title": { type: "STRING" },
                    "children": { type: "ARRAY", items: childItemSchema }
                },
                required: ["title"]
            };

            const mindMapSchema = {
                type: "OBJECT",
                properties: {
                    "central": { type: "STRING" },
                    "branches": { type: "ARRAY", items: branchItemSchema }
                },
                required: ["central"]
            };

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: mindMapSchema,
                    temperature: 0.6, 
                    maxOutputTokens: 2048
                }
            };

            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(\`API Error: ${response.status}. Details: ${errorBody.substring(0, 300)}\`);
            }

            const data = await response.json();
            if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                throw new Error('Resposta da API em formato inesperado.');
            }

            const generatedText = data.candidates[0].content.parts[0].text;
            try {
                const parsed = JSON.parse(generatedText);

                function  processNodeText(node) {
                    if (node.title) node.title = truncateText(node.title);
                    if (node.children) node.children.forEach(processNodeText);
                }
                if (parsed.central) parsed.central = truncateText(parsed.central);
                if (parsed.branches) parsed.branches.forEach(processNodeText);

                return parsed;
            } catch (e) {
                throw new Error('A IA retornou um JSON inv√°lido.');
            }
        }

        function renderMindMap(data, svgWidth, svgHeight) {
            svgElement = document.getElementById('mindMapSvg');
            rootGroup = document.getElementById('mindMapRootGroup');
            debugInfoElement = document.getElementById('debugInfo');
            rootGroup.innerHTML = ''; 
            nodePositions.clear();

            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;

            svgElement.setAttribute('viewBox', \`0 0 ${svgWidth} ${svgHeight}\`);

            const centralNodeData = createNodeElement(data.central, centerX, centerY, 0, 0, true);
            rootGroup.appendChild(centralNodeData.group);

            const centralNodeInfo = {
                x: centerX, y: centerY,
                width: centralNodeData.width, height: centralNodeData.height
            };
            nodePositions.set('central', centralNodeInfo);

            if (data.branches && data.branches.length > 0) {
                const numBranches = data.branches.length;
                let angleStep = (2 * Math.PI) / numBranches;
                if (numBranches > 1 && angleStep < MIN_ANGLE_BETWEEN_BRANCHES) {
                    console.warn(\`√Çngulo entre ramos (${angleStep*180/Math.PI}¬∞) √© menor que o m√≠nimo. Ajustando para ${MIN_ANGLE_BETWEEN_BRANCHES*180/Math.PI}¬∞\`);
                    angleStep = MIN_ANGLE_BETWEEN_BRANCHES;
                }


                data.branches.forEach((branch, index) => {
                    if (!branch || !branch.title || branch.title.trim() === '') return;

                    let angle = (index * angleStep) - (Math.PI / 2); 
                    if (numBranches === 1) angle = -Math.PI / 2; 

                    const branchRadius = LEVEL_DISTANCE_FACTOR * 0.9 + (Math.random() * 20 - 10);
                    const initialBranchX = centerX + Math.cos(angle) * branchRadius;
                    const initialBranchY = centerY + Math.sin(angle) * branchRadius;

                    drawBranchRecursive(branch, initialBranchX, initialBranchY, centralNodeInfo, 1, angle, rootGroup, index);
                });
            }

            updateDebugInfo();
            resetViewHandler();
            setupSVGInteractions();
        }

        function calculateNodeMetrics(text, level, isCentral = false) {
            const displayText = truncateText(text);
            const fontSize = isCentral ? BASE_FONT_SIZE + 4 : BASE_FONT_SIZE + Math.max(0, 3 - level);
            const rectHeight = isCentral ? BASE_NODE_HEIGHT + 10 : BASE_NODE_HEIGHT + Math.max(0, (3 - level) * 4);
            const fontWeight = isCentral ? '700' : (level === 1 ? '600' : '500');

            const tempText = createSVGElement('text', {
                style: \`font-size: ${fontSize}px; font-family: Poppins, sans-serif; font-weight: ${fontWeight}; visibility: hidden;\`,
            }, displayText);

            if (!svgElement || !svgElement.appendChild) { 
                 console.warn("calculateNodeMetrics: svgElement n√£o est√° pronto ou n√£o tem appendChild.");
                 return { width: 150, height: rectHeight}; 
            }
            svgElement.appendChild(tempText);
            const textWidth = tempText.getComputedTextLength();
            svgElement.removeChild(tempText);

            const rectWidth = Math.max(textWidth + NODE_PADDING.x * 2, 80);
            return { width: rectWidth, height: rectHeight };
        }

        function drawBranchRecursive(branchData, initialX, initialY, parentNodeInfo, level, parentAngle, parentSvgGroup, branchIndex) {
            const originalNodeText = branchData.title;
            if (!originalNodeText || typeof originalNodeText !== 'string' || originalNodeText.trim() === "") return;

            const nodeKey = \`node-${level}-${branchIndex}-${parentSvgGroup.childNodes.length}\`;
            const metrics = calculateNodeMetrics(originalNodeText, level, false);
            const { x: finalX, y: finalY } = adjustPosition(initialX, initialY, metrics.width, metrics.height, nodeKey);

            const nodeData = createNodeElement(originalNodeText, finalX, finalY, level, branchIndex, false);
            parentSvgGroup.appendChild(nodeData.group);

            nodePositions.set(nodeKey, {
                x: finalX, y: finalY, width: nodeData.width, height: nodeData.height
            });

            const link = createLinkElement(parentNodeInfo.x, parentNodeInfo.y, finalX, finalY, level, nodeData.width/2, nodeData.height/2);
            parentSvgGroup.insertBefore(link, nodeData.group); 

            if (branchData.children && branchData.children.length > 0) {
                const numChildren = branchData.children.length;
                const maxSpread = Math.PI / (1.5 + level * 0.2); 
                const minSpread = Math.PI / 8;
                let currentSpreadAngle = Math.max(minSpread, Math.min(maxSpread, Math.PI / (1.2 + level * 0.4 + Math.max(0, numChildren - 2) * 0.3)));
                if (numChildren === 1) currentSpreadAngle = 0; 

                const childRadius = LEVEL_DISTANCE_FACTOR * Math.max(0.35, (0.75 - level * 0.12)); 

                branchData.children.forEach((child, childIdx) => {
                    if (!child || !child.title || child.title.trim() === '') return;

                    let childAngle;
                    if (numChildren === 1) {
                        childAngle = parentAngle; 
                    } else {
                        childAngle = parentAngle - (currentSpreadAngle / 2) + (childIdx / (numChildren - 1)) * currentSpreadAngle;
                    }

                    const angleVariation = (Math.random() - 0.5) * (Math.PI / 18 / (level + 1)); 
                    childAngle += angleVariation;

                    const childInitialX = finalX + Math.cos(childAngle) * childRadius;
                    const childInitialY = finalY + Math.sin(childAngle) * childRadius;

                    drawBranchRecursive(child, childInitialX, childInitialY, { x: finalX, y: finalY, width: nodeData.width, height: nodeData.height }, level + 1, childAngle, parentSvgGroup, branchIndex);
                });
            }
        }

        function createSVGElement(tag, attributes = {}, textContent = null) {
            const element = document.createElementNS(SVG_NAMESPACE, tag);
            for (const attr in attributes) {
                element.setAttribute(attr, attributes[attr]);
            }
            if (textContent) {
                element.textContent = textContent;
            }
            return element;
        }

        function createNodeElement(text, x, y, level, branchIndex, isCentral = false) {
            const originalText = text;
            const displayText = truncateText(originalText, isCentral ? MAX_TEXT_LENGTH + 5 : MAX_TEXT_LENGTH); 

            const group = createSVGElement('g', {
                class: 'node-group',
                transform: \`translate(${x},${y})\`
            });

            const fontSize = isCentral ? BASE_FONT_SIZE + 3 : BASE_FONT_SIZE + Math.max(0, 2 - level);
            const currentRectHeight = isCentral ? BASE_NODE_HEIGHT + 8 : BASE_NODE_HEIGHT + Math.max(0, (2 - level) * 3);
            const fontWeight = isCentral ? '600' : (level === 1 ? '500' : '400');

            const tempText = createSVGElement('text', {
                style: \`font-size: ${fontSize}px; font-family: Poppins, sans-serif; font-weight: ${fontWeight}; visibility: hidden;\`
            }, displayText);

            let computedTextWidth = displayText.length * fontSize * 0.6; 
            if (svgElement && svgElement.appendChild) {
                svgElement.appendChild(tempText);
                computedTextWidth = tempText.getComputedTextLength();
                svgElement.removeChild(tempText);
            } else {
                console.warn("createNodeElement: svgElement n√£o est√° pronto para medir texto.");
            }

            const currentRectWidth = Math.max(computedTextWidth + NODE_PADDING.x * 2, isCentral ? 100 : 70);

            let colorIdx;
            const nodeColors = getCurrentNodeColors();
            if (isCentral) {
                colorIdx = 0;
            } else {
                colorIdx = (branchIndex % (nodeColors.length - 1)) + 1; 
                if (colorIdx >= nodeColors.length) colorIdx = 1; 
            }
            const fillColor = nodeColors[colorIdx % nodeColors.length];

            const rect = createSVGElement('rect', {
                class: 'node-rect',
                x: -currentRectWidth / 2,
                y: -currentRectHeight / 2,
                width: currentRectWidth,
                height: currentRectHeight,
                rx: level < 2 ? 12 : 8, 
                ry: level < 2 ? 12 : 8,
                style: \`fill: ${fillColor}; stroke: ${shadeColor(fillColor, -25)}; stroke-width: 1.5px;\` 
            });

            const textElement = createSVGElement('text', {
                class: 'node-text',
                'font-size': fontSize,
                'font-weight': fontWeight
            }, displayText);
            group.dataset.fullText = originalText;

            group.appendChild(rect);
            group.appendChild(textElement);
            return { group, width: currentRectWidth, height: currentRectHeight };
        }

        function shadeColor(color, percent) { 
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  

            R = Math.max(0,R);
            G = Math.max(0,G);
            B = Math.max(0,B);

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return \`#${RR}${GG}${BB}\`;
        }

        function createLinkElement(x1, y1, x2, y2, level, targetNodeHalfWidth, targetNodeHalfHeight) {
            const path = createSVGElement('path', { class: 'link-path' });

            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);

            let ratio = 0.9; 
            if (distance > 0) {
                const angleToTarget = Math.atan2(dy, dx);
                let intersectDist = Math.min(
                    Math.abs(targetNodeHalfWidth / Math.cos(angleToTarget || 1e-9)), 
                    Math.abs(targetNodeHalfHeight / Math.sin(angleToTarget || 1e-9))  
                );
                intersectDist = Math.min(intersectDist, distance * 0.8); 
                ratio = (distance - intersectDist - 2) / distance; 
            }

            const adjustedX2 = x1 + dx * ratio;
            const adjustedY2 = y1 + dy * ratio;

            const midX = (x1 + adjustedX2) / 2;
            const midY = (y1 + adjustedY2) / 2;
            const controlOffset = distance * 0.20 * (level % 2 === 0 ? 1 : -0.7); 
            const controlX = midX + (dy / (distance || 1)) * controlOffset; 
            const controlY = midY - (dx / (distance || 1)) * controlOffset; 

            path.setAttribute('d', \`M ${x1} ${y1} Q ${controlX} ${controlY} ${adjustedX2} ${adjustedY2}\`);

            const nodeColors = getCurrentNodeColors();
            path.style.stroke = shadeColor(nodeColors[(level) % nodeColors.length], currentTheme === 'light' ? -15 : 15); 
            return path;
        }

        function setupSVGInteractions() {
            if (!svgElement) svgElement = document.getElementById('mindMapSvg');
            svgElement.addEventListener('mousedown', onPointerDown);
            svgElement.addEventListener('mousemove', onPointerMove);
            svgElement.addEventListener('mouseup', onPointerUp);
            svgElement.addEventListener('mouseleave', onPointerUp); 
            svgElement.addEventListener('wheel', onWheelScroll, { passive: false }); 
            svgElement.addEventListener('touchstart', onPointerDown, { passive: false });
            svgElement.addEventListener('touchmove', onPointerMove, { passive: false });
            svgElement.addEventListener('touchend', onPointerUp);
            svgElement.addEventListener('touchcancel', onPointerUp);
        }

        function getPointerCoordinates(event) {
            if (event.touches && event.touches.length > 0) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function onPointerDown(e) {
            e.preventDefault(); 
            isDragging = true;
            const coords = getPointerCoordinates(e);
            lastPointerX = coords.x;
            lastPointerY = coords.y;
            svgElement.style.cursor = 'grabbing';
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const coords = getPointerCoordinates(e);
            const deltaX = coords.x - lastPointerX;
            const deltaY = coords.y - lastPointerY;
            currentTranslateX += deltaX;
            currentTranslateY += deltaY;
            updateTransform();
            lastPointerX = coords.x;
            lastPointerY = coords.y;
        }

        function onPointerUp() {
            if (isDragging) {
                isDragging = false;
                svgElement.style.cursor = 'grab';
            }
        }

        function onWheelScroll(e) {
            e.preventDefault(); 
            const delta = e.deltaY > 0 ? 0.85 : 1.15; 
            const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentScale * delta)); 

            const svgRect = svgElement.getBoundingClientRect();
            const pointerX = e.clientX - svgRect.left; 
            const pointerY = e.clientY - svgRect.top;  

            currentTranslateX = pointerX - (pointerX - currentTranslateX) * (newScale / currentScale);
            currentTranslateY = pointerY - (pointerY - currentTranslateY) * (newScale / currentScale);
            currentScale = newScale;
            updateTransform();
        }

        function updateTransform() {
            if (!rootGroup) rootGroup = document.getElementById('mindMapRootGroup');
            rootGroup.setAttribute('transform', \`translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})\`);
            updateDebugInfo();
        }

        function zoomHandler(zoomFactor) {
            const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentScale * zoomFactor));
            if (newScale === currentScale) return; 

            const svgRect = svgElement.getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;

            currentTranslateX = centerX - (centerX - currentTranslateX) * (newScale / currentScale);
            currentTranslateY = centerY - (centerY - currentTranslateY) * (newScale / currentScale);
            currentScale = newScale;
            updateTransform();
        }

        function zoomInHandler() { zoomHandler(1.25); }
        function zoomOutHandler() { zoomHandler(0.8); }

        function resetViewHandler() {
            currentScale = 1; 
            const svgWidth = mindMapContainerElement.clientWidth;
            const svgHeight = mindMapContainerElement.clientHeight;

            if (rootGroup && typeof rootGroup.getBBox === 'function' && rootGroup.childNodes.length > 0) {
                try {
                    const contentBBox = rootGroup.getBBox();
                     if (contentBBox.width > 0 && contentBBox.height > 0 && isFinite(contentBBox.x) && isFinite(contentBBox.y)) {
                        const scaleToFitWidth = svgWidth / contentBBox.width;
                        const scaleToFitHeight = svgHeight / contentBBox.height;
                        currentScale = Math.min(scaleToFitWidth, scaleToFitHeight) * 0.90; 
                        currentScale = Math.max(MIN_ZOOM, Math.min(1.2, currentScale)); 

                        currentTranslateX = (svgWidth / 2) - (contentBBox.x + contentBBox.width / 2) * currentScale;
                        currentTranslateY = (svgHeight / 2) - (contentBBox.y + contentBBox.height / 2) * currentScale;
                    } else { 
                        currentTranslateX = 0; 
                        currentTranslateY = 0;
                        currentScale = 1;
                    }
                } catch (e) { 
                    console.warn("Erro ao calcular BBox para recentralizar:", e);
                    currentTranslateX = 0; 
                    currentTranslateY = 0;
                    currentScale = 1;
                }
            } else { 
                 currentTranslateX = 0; 
                 currentTranslateY = 0;
                 currentScale = 1;
            }
            updateTransform();
        }

        function updateDebugInfo() {
            if (debugInfoElement) {
                 debugInfoElement.style.display = 'block';
                 debugInfoElement.innerHTML = \`
                    Scale: ${currentScale.toFixed(2)}<br>
                    TX: ${currentTranslateX.toFixed(0)}px, TY: ${currentTranslateY.toFixed(0)}px<br>
                    Nodes: ${nodePositions.size}
                \`;
            }
        }

        function showLoading(show) {
            loadingElement.style.display = show ? 'block' : 'none';
        }
        function showError(message) {
            errorContainerElement.innerHTML = \`<div class="error-message">${message}</div>\`;
        }
        function clearError() {
            errorContainerElement.innerHTML = '';
        }
        function clearAll() {
            textInputElement.value = '';
            mindMapContainerElement.classList.add('hidden');
            if (rootGroup) rootGroup.innerHTML = '';
            if (debugInfoElement) debugInfoElement.style.display = 'none';
            nodePositions.clear();
            clearError();
            currentScale = 1;
            currentTranslateX = 0;
            currentTranslateY = 0;
            updateTransform();
            if (exportPngButtonElement) exportPngButtonElement.disabled = true; // Desabilitar ao limpar
        }

        function askAndSetApiKey() {
            userApiKey = prompt("Por favor, insira a sua chave da API Gemini para utilizar a aplica√ß√£o:", "");
            if (!userApiKey || userApiKey.trim() === "") {
                showError("Chave da API n√£o fornecida. A gera√ß√£o de mapas mentais est√° desativada. Recarregue a p√°gina para tentar novamente.");
                if(generateMapButton) generateMapButton.disabled = true;
                if(exportPngButtonElement) exportPngButtonElement.disabled = true; // Desabilitar exporta√ß√£o tamb√©m
            } else {
                 if(generateMapButton) generateMapButton.disabled = false;
                 // O bot√£o de exportar permanece desabilitado at√© que um mapa seja gerado
                 if(exportPngButtonElement) exportPngButtonElement.disabled = true; 
                 clearError(); 
            }
        }


        textInputElement.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault(); 
                generateMindMap();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            svgElement = document.getElementById('mindMapSvg');
            rootGroup = document.getElementById('mindMapRootGroup');
            debugInfoElement = document.getElementById('debugInfo');
            generateMapButton = document.getElementById('generateMapBtn');
            exportPngButtonElement = document.getElementById('exportPngBtn'); // Obt√©m o bot√£o de exportar PNG
            emojiThemeToggleElement = document.createElement('div'); 
            emojiThemeToggleElement.id = 'emojiThemeToggle';

            // Adiciona o novo controle de tema ao header
            const headerElement = document.querySelector('.header');
            if (headerElement) {
                headerElement.appendChild(emojiThemeToggleElement);
            } else {
                console.error("Elemento .header n√£o encontrado para adicionar o seletor de tema emoji.");
            }

            emojiThemeToggleElement.textContent = currentTheme === 'light' ? '‚òÄÔ∏è' : 'üåô'; 
            emojiThemeToggleElement.onclick = toggleTheme; 

            if (exportPngButtonElement) {
                exportPngButtonElement.addEventListener('click', exportMindMapAsPng);
            } else {
                console.error("Bot√£o de exportar PNG n√£o encontrado.");
            }

            askAndSetApiKey(); 

            if (!svgElement || !rootGroup) {
                console.error("Elementos SVG principais n√£o encontrados!");
            } else {
                 setupSVGInteractions();
                 resetViewHandler();
            }
            // N√£o √© mais necess√°rio atualizar o texto do bot√£o antigo
        });

    </script>
</body>
</html>
